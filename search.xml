<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Azkaban-1.搭建Azkaban源代码阅读环境</title>
    <url>/2020/05/23/Azkaban-1.%E6%90%AD%E5%BB%BAAzkaban%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在公司的日常工作中， 经常会用到 Azkaban。作为一种工作流管理系统, 对我来说, 的确有学习的价值。</p>
<p>本文将会使用最新版的Azkaban源代码, 编译并搭建一套可运行调试的系统。开发工具使用的是IDEA, 运行环境是CentOS7。</p>
<h4 id="从github下载源代码"><a href="#从github下载源代码" class="headerlink" title="从github下载源代码"></a>从github下载源代码</h4><p>截止目前，最新的tag版本是: 3.86.0<br>可以直接点击下载源码: <a href="https://github.com/azkaban/azkaban/archive/3.86.0.zip " target="_blank" rel="noopener">3.86.0</a></p>
<a id="more"></a>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>用IDEA打开, File -&gt; Open… -&gt; 选择已解压的代码目录 -&gt; 点击 OK。<br>此时, IDEA会自动同步一些Gradle项目的配置，稍微等待一会。</p>
<p>为了解决gradle项目下载依赖慢的问题， 我们可以加上阿里云的maven仓库地址。<br>在azkaban根目录下的 build.gradle 中加入下面内容即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">"http://maven.aliyun.com/nexus/content/groups/public"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>加入后的效果是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  apply plugin: &#39;jacoco&#39;</span><br><span class="line"></span><br><span class="line">  repositories &#123;</span><br><span class="line">    maven &#123; url &quot;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&quot; &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    mavenLocal()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 这里需要保留原来的仓库地址, 因为有些依赖阿里云仓库下载不到</p>
</blockquote>
<p>再配置一个 npm的淘宝源, 毕竟国外的不太稳定。<br>在用户目录下, 创建 .npmrc 文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.npmrc</span><br></pre></td></tr></table></figure>

<p>再加入以下内容即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>


<p>配置好之后, 我们就可以执行以下命令编译了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew build -x <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>编译成功后, 就有了az-web 和 az-exec 的可运行程序压缩包了。</p>
<h4 id="数据库、表初始化"><a href="#数据库、表初始化" class="headerlink" title="数据库、表初始化"></a>数据库、表初始化</h4><p>推荐使用 MySQL5.7.x </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line">mysql&gt; CREATE DATABASE azkaban;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建用户, username/password 自定义</span></span><br><span class="line">mysql&gt; CREATE USER 'username'@'%' IDENTIFIED BY 'password';</span><br><span class="line"></span><br><span class="line"><span class="comment">--授权, &lt;username&gt; 改为你自己的用户名 </span></span><br><span class="line">mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE ON azkaban.* to '&lt;username&gt;'@'%' WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>调整Mysql Packet Size, 找到MySQL的配置文件,修改<code>max_allowed_packet=1024M</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">max_allowed_packet&#x3D;1024M</span><br></pre></td></tr></table></figure>

<p>重启MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;service mysqld restart</span><br></pre></td></tr></table></figure>

<p>使用初始化sql建表:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 位置</span></span><br><span class="line">azkaban-3.86.0\azkaban-db\build\sql\create-all-sql-0.1.0-SNAPSHOT.sql</span><br></pre></td></tr></table></figure>

<h4 id="运行azkaban-Exec节点"><a href="#运行azkaban-Exec节点" class="headerlink" title="运行azkaban Exec节点"></a>运行azkaban Exec节点</h4><p>编译后的压缩包路径: azkaban-exec-server/build/distributions/azkaban-exec-server-0.1.0-SNAPSHOT.zip</p>
<p>1.更改配置文件<br>上传 azkaban-exec-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-exec-server/conf/azkaban.properties 配置文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库信息</span></span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=192.168.3.25</span><br><span class="line">mysql.database=azkaban</span><br><span class="line">mysql.user=root</span><br><span class="line">mysql.password=123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行节点信息</span></span><br><span class="line">executor.port=12321</span><br><span class="line">azkaban.use.multiple.executors=<span class="literal">true</span></span><br><span class="line">azkaban.executorselector.filters=StaticRemainingFlowSize,MinimumFreeMemory,CpuStatus</span><br><span class="line">azkaban.executorselector.comparator.NumberOfAssignedFlowComparator=1</span><br><span class="line">azkaban.executorselector.comparator.Memory=1</span><br><span class="line">azkaban.executorselector.comparator.LastDispatched=1</span><br><span class="line">azkaban.executorselector.comparator.CpuUsage=1</span><br></pre></td></tr></table></figure>

<p>2.设置远程debug<br>2.1 编辑文件 azkaban-exec-server/bin/internal/internal-start-executor.sh， <strong>增加</strong>一个 AZKABAN_OPTS 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">AZKABAN_OPTS=<span class="string">"<span class="variable">$AZKABAN_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5554"</span></span><br><span class="line">java <span class="variable">$AZKABAN_OPTS</span> <span class="variable">$JAVA_LIB_PATH</span> -cp <span class="variable">$CLASSPATH</span> azkaban.execapp.AzkabanExecutorServer -conf <span class="variable">$conf</span> <span class="variable">$@</span> &amp;</span><br></pre></td></tr></table></figure>

<p>2.2 IDEA中配置<br>点击编辑运行时配置 -&gt; 点击左上角的 <code>+</code> ，选择 Remote 选项。配置如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.3.png"><br>说明:</p>
<ul>
<li>Host: 为az执行节点的IP</li>
<li>Port: 为 上面我们配置的那个远程debug端口</li>
<li>Use module classpath: 为az-exec模块的main</li>
</ul>
<p>点击OK即可, 需要远程服务先启动,才能进行远程debug操作。</p>
<p>3.运行并激活az-exec<br>运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> azkaban-exec-server</span><br><span class="line">bin/start-exec.sh</span><br></pre></td></tr></table></figure>

<p>激活:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -G &quot;http:&#x2F;&#x2F;192.168.3.25:12321&#x2F;executor?action&#x3D;activate&quot; &amp;&amp; echo</span><br></pre></td></tr></table></figure>
<ul>
<li>192.168.3.25:12321 为 az执行节点的地址</li>
</ul>
<p>此时, 可以发现azkaban库 executors 表中已经有执行节点的记录<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.4.png"></p>
<h4 id="运行azkaban-Web节点"><a href="#运行azkaban-Web节点" class="headerlink" title="运行azkaban Web节点"></a>运行azkaban Web节点</h4><p>编译后的压缩包路径:<br>azkaban-web-server/build/distributions/azkaban-web-server-0.1.0-SNAPSHOT.zip</p>
<p>1.更改配置文件<br>上传 azkaban-web-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-web-server/conf/azkaban.properties 配置文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库信息</span></span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=192.168.3.25</span><br><span class="line">mysql.database=azkaban</span><br><span class="line">mysql.user=root</span><br><span class="line">mysql.password=123456</span><br></pre></td></tr></table></figure>

<p>2.设置远程debug<br>2.1 编辑文件 azkaban-web-server/bin/internal/internal-start-web.sh， <strong>增加</strong>一个 AZKABAN_OPTS 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">AZKABAN_OPTS=<span class="string">"<span class="variable">$AZKABAN_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555"</span></span><br><span class="line">java <span class="variable">$AZKABAN_OPTS</span> <span class="variable">$JAVA_LIB_PATH</span> -cp <span class="variable">$CLASSPATH</span> azkaban.webapp.AzkabanWebServer -conf <span class="variable">$conf</span> <span class="variable">$@</span> &amp;</span><br></pre></td></tr></table></figure>

<p>2.2 IDEA中配置<br>点击编辑运行时配置 -&gt; 点击左上角的 <code>+</code> ，选择 Remote 选项。配置如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.5.png"></p>
<p>3.运行az-web</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> azkaban-web-server</span><br><span class="line">bin/start-web.sh</span><br></pre></td></tr></table></figure>

<p>4.登录<br>Azkaban默认使用的xml来管理用户。配置文件目录: azkaban-web-server/conf/azkaban-users.xml<br>访问 <a href="http://192.168.3.25:8081" target="_blank" rel="noopener">http://192.168.3.25:8081</a>, 使用azkaban/azkaban 即可登录。</p>
<ul>
<li>192.168.3.25: 为 az-web的ip</li>
<li>8081: 为az-web的端口</li>
</ul>
<h4 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h4><p>在 az-web 和 az-exec 都启动之后, 先确保所有端口都能正常访问, 我这儿配置的是 </p>
<ul>
<li>az-exec服务端口: 12321</li>
<li>az-exec远程debug端口: 5554</li>
<li>az-web服务端口: 8091</li>
<li>az-web远程debug端口: 5555</li>
</ul>
<p>然后在IDEA中运行下图中的这两项即可。<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.6.png" ><br>在想要看细节的地方打上断点, 就可以愉快玩耍啦。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Azkaban</tag>
        <tag>调试</tag>
        <tag>IDEA</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习</title>
    <url>/2020/10/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
    width: 17%;
}
table th:nth-of-type(2){
    width: 83%;
}
</style>


<h5 id="正则示例"><a href="#正则示例" class="headerlink" title="正则示例"></a>正则示例</h5><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>this is text</td>
<td>匹配字符串 “this is text”</td>
</tr>
<tr>
<td>this\s+is\s+text</td>
<td>注意字符串中的 \s+。匹配单词 “this” 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td>
</tr>
<tr>
<td>^\d+(.\d+)?</td>
<td>^ 定义了以什么开始; \d+ 匹配一个或多个数字; ? 设置括号内的选项是可选的; . 匹配 “.”; 可以匹配的实例：”5”, “1.5” 和 “2.21”。</td>
</tr>
</tbody></table>
<a id="more"></a>

<h5 id="java中的正则"><a href="#java中的正则" class="headerlink" title="java中的正则"></a>java中的正则</h5><p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p>Pattern 类：<br>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
</li>
<li><p>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<ul>
<li>matches()  尝试将整个字符串序列与该模式匹配</li>
<li>find()  该方法扫码输入的序列, 查找与该模式匹配的<code>下一个</code>子序列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pattern PATTERN &#x3D; Pattern.compile(&quot;\\d+ \\w+&quot;);</span><br><span class="line">Matcher matcher &#x3D; PATTERN.matcher(&quot;1 apple&quot;);</span><br><span class="line">boolean find &#x3D; matcher.find();</span><br><span class="line">System.out.println(&quot;find:&quot; + find);</span><br><span class="line">boolean find1 &#x3D; matcher.find();</span><br><span class="line">System.out.println(&quot;find1:&quot; + find1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; output</span><br><span class="line">find:true</span><br><span class="line">find1:false</span><br></pre></td></tr></table></figure></li>
<li>group() 捕获组取值, 一般与find() 一起用</li>
<li>group(num) 捕获组取值, 一般与matches() 一起用</li>
</ul>
</li>
<li><p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<p>一般是两种用途: </p>
<ol>
<li>判断字符串中是否包含某个子串; </li>
<li>提取某个字符串中符合正则规则的内容</li>
</ol>
<blockquote>
<p>注: 正则中的 <code>\</code> 在Java中需要使用 <code>\\</code></p>
</blockquote>
<h5 id="正则表达式-匹配字符-集合"><a href="#正则表达式-匹配字符-集合" class="headerlink" title="正则表达式-匹配字符(集合)"></a>正则表达式-匹配字符(集合)</h5><ul>
<li><p>匹配普通字符:<br>字母、数字、汉字、下划线, 以及没有特殊定义的标点符号</p>
</li>
<li><p>匹配转义字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>代表换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\、^、$、(、)、{、}、?、+、*、\、|、[、]</td>
<td>代表字符本身(就是在正则表达式中有特殊作用的字符需要做转义处理)</td>
</tr>
</tbody></table>
</li>
<li><p>标准字符集合</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>数字字符匹配。等效于 [0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效</td>
</tr>
<tr>
<td>\W</td>
<td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效</td>
</tr>
<tr>
<td>.</td>
<td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式</td>
</tr>
</tbody></table>
</li>
<li><p>自定义字符集合<br>[] 方括号匹配方式, 能够匹配方括号中的任意一个字符。</p>
<table>
<thead>
<tr>
<th>字符集合</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ab5@]</td>
<td>匹配 a 或 b 或 5 或 @</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配 a、 b、 c之外的任意一个字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配 a~z 之间的任意一个字符</td>
</tr>
<tr>
<td>[^A-F0-3]</td>
<td>匹配 A<del>F, 0</del>3 之外的任意一个字符</td>
</tr>
</tbody></table>
</li>
</ul>
<p>注意: </p>
<ol>
<li>正则表达式的特殊符号, 被包含到中括号中, 则失去特殊意义, 除了 ^ 和 - 之外</li>
<li>标准字符集合, 除小数点外, 如果被包含于中括号中, 自定义字符集合将包含该集合, 比如: [\d.-+] 将匹配: 数字 或 小数点 或 + 或 -</li>
</ol>
<h5 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h5><ul>
<li>修饰匹配次数的特殊符号。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>{n}</td>
<td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td>?</td>
<td>匹配表达式0次或1次, 相当于 {0,1}</td>
</tr>
<tr>
<td>+</td>
<td>表达式至少出现一次, 相当于 {1,}</td>
</tr>
<tr>
<td>*</td>
<td>表达式不出现或者出现任意次, 相当于{0,}</td>
</tr>
</tbody></table>
<p>注:</p>
<ul>
<li>{0,1} 中逗号左边必须有, 不能有 {,6} 这种形式</li>
<li>匹配规则默认为贪婪模式, 即匹配字符越多越好</li>
<li>匹配次数中的非贪婪模式(匹配字符越少越好, 修饰匹配次数的特殊符合后再加一个 ?)</li>
</ul>
<h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><ul>
<li>匹配符合某种条件的位置<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>字符串开始的地方进行匹配([]外)</td>
</tr>
<tr>
<td>$</td>
<td>字符串结束的地方进行匹配</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单次边界，即前面或后面的字符至少有一个是[A-Za-z0-9_]以外的字符</td>
</tr>
<tr>
<td>^A</td>
<td>多行模式下, 匹配第一个出现的字符</td>
</tr>
<tr>
<td>^Z</td>
<td>多行模式下, 匹配最后一个出现的字符</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="选择符和分组"><a href="#选择符和分组" class="headerlink" title="选择符和分组"></a>选择符和分组</h5><table>
<thead>
<tr>
<th align="left">字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>|</code></td>
<td>或</td>
</tr>
<tr>
<td align="left">()</td>
<td>匹配 pattern 并捕获该匹配的子表达式。可以使用 <code>$0</code>…<code>$9</code> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“</td>
</tr>
</tbody></table>
<h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><ul>
<li>每一对 ()会分配一个编号, 使用 () 的捕获根据<code>左括号的顺序</code>从1开始自动编号</li>
<li>通过反向引用, 可以对已捕获的字符串进行引用</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 小技巧</title>
    <url>/2020/11/29/mysql-tips/</url>
    <content><![CDATA[<p>接下来一段时间, 会将主要精力投入在SQL优化 以及工作中常用的一些SQL小技巧总结。当然啦, 也会对Hive、Spark SQL 和 Presto 中的SQL使用做一些总结。之前SQL写得比较少, 更多的是用的pyspark进行大数据处理, 后端服务更多的用Mybatis自动生成工具来生成DAO层SQL代码,然后在Service层进行多次调用, 一是因为业务逻辑不复杂, 二是因为性能要求也没那么高。不过, 总感觉SQL这块如果不掌握的话, 可能后面发展会受限。好了, 废话不多说, 我们开始一段时间的 SQL 之旅吧。</p>
<a id="more"></a>

<h4 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h4><p>表1. user:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/user.png"></p>
<p>表2. job:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/job.png"></p>
<p>表3. sports_duration:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/sports_duration.png"></p>
<h4 id="1-如何在MySQL中使用full-join"><a href="#1-如何在MySQL中使用full-join" class="headerlink" title="1. 如何在MySQL中使用full join?"></a>1. 如何在MySQL中使用full join?</h4><p>场景: 将上面的user 表和 job表 合成一张大表。</p>
<p>full join 就是取两者的并集, 而MySQL中是不能使用full join 的, 下面来说下解决方法:<br>使用表user left join 表job, 然后 union all 表user right join 表job(其实也就是表job left join 表user)即可, union all 就是两者的并集。</p>
<p>sql 如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, j.name <span class="keyword">as</span> jname, j.job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">JOIN</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.name</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, j.name <span class="keyword">as</span> jname, j.job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">right</span> <span class="keyword">JOIN</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.name;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/full_join.png"></p>
<p>通过上图, 我们也可以很清楚的看到 left join 和 right join 后的效果。<br>user left join job 就是user 表作为主表, 将 job 表中与 user表有关联关系的数据作为补充, 详见 上图 left join 红框。<br>另外, 通过指定 where jname is null, 我们也可以取到 user 表中有而 job 表中不存在的用户。<br>right join 同理, 这里就不赘述了。</p>
<h4 id="2-如何更新使用过滤条件中包括自身的表？"><a href="#2-如何更新使用过滤条件中包括自身的表？" class="headerlink" title="2. 如何更新使用过滤条件中包括自身的表？"></a>2. 如何更新使用过滤条件中包括自身的表？</h4><p>场景: 把同时存在于 user表 和 job表的记录的用户在user 表中的age 字段更新为30。<br>错误示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age=<span class="number">30</span> <span class="keyword">where</span> user.name <span class="keyword">in</span> (<span class="keyword">select</span> j.name <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> job j <span class="keyword">on</span> u.name=j.name);</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set age&#x3D;30 where user.name in (select j.name from user u join job j on u.name&#x3D;j.name)</span><br><span class="line">&gt; 1093 - You can&#39;t specify target table &#39;user&#39; for update in FROM clause</span><br></pre></td></tr></table></figure>
<p>说明： MySQL 中不支持这样操作, 在 SQLServer 或者 Oracle中可以正常执行。 </p>
<p>正确解法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> u <span class="keyword">join</span> (<span class="keyword">select</span> j.name <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> job j <span class="keyword">on</span> u.name=j.name) j <span class="keyword">on</span> a.name=j.name <span class="keyword">set</span> u.age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>更新结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/user_join_update.png"></p>
<h4 id="3-如何使用-join-来优化子查询"><a href="#3-如何使用-join-来优化子查询" class="headerlink" title="3. 如何使用 join 来优化子查询?"></a>3. 如何使用 join 来优化子查询?</h4><p>先看下面这个带有子查询的sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, (<span class="keyword">select</span> job <span class="keyword">from</span> job <span class="keyword">where</span> job.name = u.name ) <span class="keyword">as</span> job <span class="keyword">from</span> <span class="keyword">user</span> u;</span><br></pre></td></tr></table></figure>

<p>使用 join 优化:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">join</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.<span class="string">`name`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-使用join来优化聚合子查询"><a href="#4-使用join来优化聚合子查询" class="headerlink" title="4. 使用join来优化聚合子查询"></a>4. 使用join来优化聚合子查询</h4><p>场景: 找出user 表中三人, 各自运动时长最长的日期。新增表 sports_duration, duration 为运动时长, 单位: 分钟</p>
<p>聚合子查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, s.day, s.duration <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">join</span> sports_duration s <span class="keyword">on</span> u.name=s.name </span><br><span class="line"><span class="keyword">where</span> s.duration=(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(c.duration) <span class="keyword">from</span> sports_duration c <span class="keyword">where</span> c.name=s.name</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/max_duration.png"></p>
<p>使用join优化后, 避免子查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, s.day, s.duration <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">join</span> sports_duration s <span class="keyword">on</span> u.name=s.name</span><br><span class="line"><span class="keyword">join</span> sports_duration c <span class="keyword">on</span> c.name=s.name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> u.name,s.day,s.duration</span><br><span class="line"><span class="keyword">having</span> s.duration=<span class="keyword">max</span>(c.duration);</span><br></pre></td></tr></table></figure>

<p>返回的结果集是相同的。</p>
<h4 id="5-如何实现分组选择"><a href="#5-如何实现分组选择" class="headerlink" title="5. 如何实现分组选择?"></a>5. 如何实现分组选择?</h4><p>在 Oracle、SQLServer、PgSQL中可以使用分区查询函数实现:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> u.name, s.day, s.duration, row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> u.name <span class="keyword">order</span> <span class="keyword">by</span> s.duration) cnt</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> sports_duration s </span><br><span class="line">    <span class="keyword">on</span> u.name = s.name</span><br><span class="line">) <span class="keyword">select</span> * <span class="keyword">from</span> tmp <span class="keyword">where</span> cnt &lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>但是, 在 MySQL中不支持。</p>
<p>我们可以这样做:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, d.day, d.duration <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span>, (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> sports_duration s <span class="keyword">where</span> s.name=c.name <span class="keyword">and</span> c.duration &lt;= s.duration) <span class="keyword">as</span> cnt <span class="keyword">from</span> sports_duration c</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span></span><br><span class="line">) d <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> d.name = u.name</span><br><span class="line"><span class="keyword">where</span> cnt &lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/duration_top_2.png"></p>
<p>下面我们来拆分这个SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, d.day, d.duration, cnt <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span>, (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> sports_duration s <span class="keyword">where</span> s.name=c.name <span class="keyword">and</span> c.duration &lt;= s.duration) <span class="keyword">as</span> cnt <span class="keyword">from</span> sports_duration c</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span></span><br><span class="line">) d <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> d.name = u.name;</span><br></pre></td></tr></table></figure>
<p>去掉 where条件, 加上返回 cnt 字段, 就可以很清晰的看到明白这个sql的逻辑了, 结果如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/duration_top_cnt.png"><br>利用子查询中统计出用户运动耗时大于等于当前运动记录的条数, 然后再进行过滤。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-索引</title>
    <url>/2021/01/15/mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引(在MySQL中也叫做”键(key)”) 是排好序的, 用于快速查找数据的一种数据结构。</p>
<p>索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。<br>在数据量较小且负载较低时, 不恰当的索引对性能的可能还不明显，但当数据量逐渐增大时, 性能则会急剧下降。</p>
<a id="more"></a>

<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/mysql-index-category1.png" width="65%" alt="MySQL索引分类">

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul>
<li>Hash索引</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-使用explain关键字</title>
    <url>/2021/01/15/mysql-explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Prestodb 日期和事件函数大全</title>
    <url>/2021/01/17/Prestodb%20%E6%97%A5%E6%9C%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>在工作中, 我们会用到很多日期和时间处理的函数, 这里我们为了方便, 来做一个使用总结, 不用每次都去查Google。</p>
<a id="more"></a>

<h3 id="日期和时间操作"><a href="#日期和时间操作" class="headerlink" title="日期和时间操作"></a>日期和时间操作</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>date ‘2012-08-08’ + interval ‘2’ day</td>
<td>2012-08-10</td>
</tr>
<tr>
<td>+</td>
<td>time ‘01:00’ + interval ‘3’ hour</td>
<td>04:00:00.000</td>
</tr>
<tr>
<td>+</td>
<td>timestamp ‘2012-08-08 01:00’ + interval ‘29’ hour</td>
<td>2012-08-09 06:00:00.000</td>
</tr>
<tr>
<td>+</td>
<td>timestamp ‘2012-10-31 01:00’ + interval ‘1’ month</td>
<td>2012-11-30 01:00:00.000</td>
</tr>
<tr>
<td>+</td>
<td>interval ‘2’ day + interval ‘3’ hour</td>
<td>2 03:00:00.000</td>
</tr>
<tr>
<td>+</td>
<td>interval ‘3’ year + interval ‘5’ month</td>
<td>3-5</td>
</tr>
<tr>
<td>-</td>
<td>date ‘2012-08-08’ - interval ‘2’ day</td>
<td>2012-08-06</td>
</tr>
<tr>
<td>-</td>
<td>time ‘01:00’ - interval ‘3’ hour</td>
<td>22:00:00.000</td>
</tr>
<tr>
<td>-</td>
<td>timestamp ‘2012-08-08 01:00’ - interval ‘29’ hour</td>
<td>2012-08-06 20:00:00.000</td>
</tr>
<tr>
<td>-</td>
<td>timestamp ‘2012-10-31 01:00’ - interval ‘1’ month</td>
<td>2012-09-30 01:00:00.000</td>
</tr>
<tr>
<td>-</td>
<td>interval ‘2’ day - interval ‘3’ hour</td>
<td>1 21:00:00.000</td>
</tr>
<tr>
<td>-</td>
<td>interval ‘3’ year - interval ‘5’ month</td>
<td>2-7</td>
</tr>
</tbody></table>
<h3 id="当前日期、时间函数"><a href="#当前日期、时间函数" class="headerlink" title="当前日期、时间函数"></a>当前日期、时间函数</h3><ul>
<li><p>current_date -&gt; date<br>返回当前日期。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_date</span></span><br><span class="line"><span class="comment">--  2021-01-17</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>current_time -&gt; time<br>返回当前时间(含时区)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_time</span></span><br><span class="line"><span class="comment">--  23:52:04.371 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 这个结果看起来有点问题, 因为我执行该条命令的真实时间为 15:52:04.371 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 可能是公司的Presto的时区设置有问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>current_timestamp -&gt; timestamp<br>返回当前的日期和时间(含时区)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span></span><br><span class="line"><span class="comment">-- 2021-01-17 15:44:43.041 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 和上面的比, 这条就正常了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>current_timezone() -&gt; varchar<br>返回当前时区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span></span><br><span class="line"><span class="comment">-- Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>now() -&gt; timestamp<br>返回当前的日期和时间(含时区)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>()</span><br><span class="line"><span class="comment">-- 2021-01-17 15:44:43.041 Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>localtime -&gt; time<br>返回当前的时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">localtime</span></span><br><span class="line"><span class="comment">-- 23:52:04.371</span></span><br><span class="line"><span class="comment">-- 遇到了和 current_time 一样的问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>localtimestamp -&gt; timestamp<br>返回当前的日期和时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">localtimestamp</span></span><br><span class="line"><span class="comment">-- 2021-01-17 15:52:04.371</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ul>
<li>date(x) -&gt; date<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select date(&#39;2012-08-10&#39;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>等价于 <code>CAST(x AS date)</code>。x 的两侧有空格 或者 x=’2012-8-10’ 都是可以正常转换的。</p>
<h4 id="日期维度函数"><a href="#日期维度函数" class="headerlink" title="日期维度函数"></a>日期维度函数</h4><ol>
<li><p>按年</p>
</li>
<li><p>按月</p>
</li>
<li><p>按季度</p>
</li>
<li><p>按周</p>
</li>
<li><p>按天</p>
</li>
</ol>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><h4 id="时间格式转换"><a href="#时间格式转换" class="headerlink" title="时间格式转换"></a>时间格式转换</h4><h4 id="时间加-减"><a href="#时间加-减" class="headerlink" title="时间加/减"></a>时间加/减</h4>]]></content>
      <categories>
        <category>函数大全</category>
        <category>Prestodb</category>
      </categories>
      <tags>
        <tag>Prestodb</tag>
      </tags>
  </entry>
</search>
