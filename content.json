{"meta":{"title":"Matthew Blog","subtitle":"","description":"","author":"Matthew","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2020-10-08T14:44:26.448Z","updated":"2020-10-08T14:44:26.448Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-08T14:55:42.000Z","updated":"2020-10-08T14:55:42.822Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-08T15:01:47.000Z","updated":"2020-10-08T15:01:47.354Z","comments":true,"path":"categories/index-2.html","permalink":"http://yoursite.com/categories/index-2.html","excerpt":"","text":""},{"title":"Tags","date":"2020-10-08T14:44:26.449Z","updated":"2020-10-08T14:44:26.449Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2020-10-08T14:44:26.446Z","updated":"2020-10-08T14:44:26.446Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"分布式共识算法Raft","slug":"分布式共识算法-Raft","date":"2022-03-05T03:51:00.000Z","updated":"2022-03-05T09:47:45.930Z","comments":true,"path":"2022/03/05/分布式共识算法-Raft/","link":"","permalink":"http://yoursite.com/2022/03/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft/","excerpt":"Raft 诞生2013 年, 斯坦福大学的 Diego Ongaro 和 John Ousterhout 发表了 Raft 论文《In Search of an Understanding Consensus Algorithm》,但是这篇论文比较短小,只是简单介绍了一下原理,对一些实现细节部分没有提及。更详细的论文是 Diego Ongaro 的博士论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》。Raft的产生就是为了代替 Paxos, 毕竟 Paxos算法自 1990 年诞生以来，就一直被诟病难以理解,这也导致了后面业界很多基于Paxos的实现都是”Paxos-like”实现。","text":"Raft 诞生2013 年, 斯坦福大学的 Diego Ongaro 和 John Ousterhout 发表了 Raft 论文《In Search of an Understanding Consensus Algorithm》,但是这篇论文比较短小,只是简单介绍了一下原理,对一些实现细节部分没有提及。更详细的论文是 Diego Ongaro 的博士论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》。Raft的产生就是为了代替 Paxos, 毕竟 Paxos算法自 1990 年诞生以来，就一直被诟病难以理解,这也导致了后面业界很多基于Paxos的实现都是”Paxos-like”实现。 基础概念共识 &amp; 一致性共识（Consensus）很多时候会与一致性（Consistency）放在一起讨论。严谨地讲，两者的含义并不完全相同。一致性的含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。具体到分布式系统场景下，一致性指的是多个副本对外呈现的状态。如前面提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。而共识，则特指在分布式系统中多个节点之间对某个事情（例如多个事务请求，先执行谁？）达成一致观点的过程。因此，达成某种共识并不意味着就保障了一致性。 拜占庭问题拜占庭问题（Byzantine Problem）又叫拜占庭将军（Byzantine Generals Problem）问题，讨论的是在少数节点有可能作恶（消息可能被伪造）的场景下，如何达成共识问题。 Raft 集群内的节点都对选举出的 Leader 采取信任, 因此, Raft 算法并不是一种拜占庭容错算法。 复制机状态机 上面是复制状态机架构图。共识算法通常出现在复制状态机的环境中, 也就是上图的 Consensus Module, 它管理着来自客户端的状态机指令的复制日志(Log)。 状态机(State Machine)处理来自日志(Log)的相同指令序列，因此它们产生相同的输出。 Raft 算法基础为了让 Raft 算法更好被人理解, Raft 设计者将一致性问题分解成了三个相对独立的子问题： 领导者选举：启动集群时或现有领导者异常时必须选出新的领导者。 日志复制：领导者接收来自客户端的日志条目，并在整个集群中复制它们，迫使其他节点的日志与自己的一致。 安全性：Raft 的安全属性的关键是状态机安全性属性：如果任一个节点已将特定的日志条目应用于其状态机，则其他节点都不可以对同一日志索引应用不同的指令。Raft 通过选举机制的额外限制以及 Leader 日志提交的任期限制来保证这一特性。 领导者选举节点状态集群中的节点主要有以下三者状态: Leader (领导者): 处理与客户端的交互和与 Follower 的日志复制等，正常情况下只有一个 Leader Follower (追随者): 被动从 Leader 同步日志，同时也会在 Leader 超时后转变为 Candidate 参与竞选，正常情况下集群中除了 Leader 之外都是 Follower Candidate (候选者): 在竞选期间参与竞选 不同状态的节点之间会发生下图所示的一些变化: 节点的初始状态都是 Follower, 当节点超时(150 ~ 300 ms, 随机), 它会成为 Candidate, 开始竞选 Leader, 当得到大多数选票时, Candidate 会变成 Leader, 否则, 所有节点会再次进入倒计时状态, 重复这个过程, 直到选出 Leader。Leader 选出后, 会周期性地向其他节点发送心跳请求, 避免新的 Leader 产生。 由 Candidate 发往其他节点的请求投票 RPC(RequestVote RPC) 的定义如下: 任期(Term)Leader 的选举引出了一个新的概念——任期（Term）。 时间被划分成一个个的任期，任期用连续单调递增的整数标记，每个任期开始都是一次选举 在选举成功后，Leader 会管理整个集群直到任期结束 (一个任期最多只会产生一个 Leader) 有时候选举会失败，那么这个任期就会没有 Leader 而结束, 如上图的 t3 当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，那么他会更新自己的编号到较大的编号值。如果 Leader 或者 Candidate 发现自己的任期号过期了，那么他会立即恢复成 Follower。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。 选举过程要开始一次选举过程, Follower 要先增加自己当前的任期号(Term)并且转换到 Candidate 状态。他会先给自己投一票, 然后并行的向集群中的其他服务器节点发送拉票请求。其他节点在收到 Candidate 发送的拉票请求后, 会根据以下规则(Leader 选举限制)判定是同意还是反对，见下图: 其他节点在收到 Candidate 的拉票请求后的判定逻辑: 如果当前节点已经给其他节点(根据 candidateId 判定, 也可以是自己)投过票, 则反对 如果 Candidate 的任期(Term)比当前节点的任期小, 则反对, 并将 Candidate 的任期设置为当前节点的任期 如果 Candidate 的 lastLogTerm(上一条日志的任期)比当前节点上一条日志的任期小, 则反对 如果 Candidate 的 lastLogIndex(上一条日志的索引)比当前节点上一条日志的索引小, 则反对 否则, 当前节点则投票给 Candidate，当前任期内, 不会再投票给其他的 Candidate 选举的动态图如下，初次选举: Leader 异常后, 重新选举: 日志复制正常复制流程如下图: 以 SET 5 为例, 日志复制的流程如下图所示: 在第一次由 Leader 复制到其他节点时, 并不会立即提交。Leader 提交日志条目的条件是该条目在大多数节点上已经存在。 日志冲突处理 当一个 Leader 成功当选时: Follower 可能会缺少一些日志条目（a-b） 可能会有一些未被提交的日志条目（c-d） 或者两种情况都存在（e-f） 在 Raft 算法中，Leader 是通过强制 Follower 直接复制它的日志来处理不一致问题的。这意味着在 Follower 中冲突的日志条目会被 Leader 的日志所覆盖。 要使得 Follower 的日志进入和自己一致的状态，Leader 必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行AppendEntries RPC(附加日志条目的 RPC 请求) 的一致性检查时完成。Leader 针对每一个 Follower 维护了一个 nextIndex，这表示下一个需要发送给 Follower 的日志条目的索引地址。当一个 Leader 刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（上图中的 11）。如果一个 Follower 的日志和 Leader 不一致，那么在下一次的AppendEntries RPC 时的一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。当这种情况发生，AppendEntries RPC 就会成功，这时就会把 Follower 冲突的日志条目全部删除并且加上 Leader 的日志。一旦AppendEntries RPC 成功，那么 Follower 的日志就会和 Leader 保持一致，并且在接下来的任期里一直继续保持。 在 Leader 发现它与 Follower 的日志匹配位置之前，Leader 可以发送不带任何条目（例如心跳）的AppendEntries RPC 以节省带宽。 然后，一旦 matchIndex(其他节点和 Leader 日志一致的索引位置) 恰好比 nextIndex 小 1，则 Leader 应开始发送实际的日志条目。 Leader 在复制日志时的AppendEntries RPC 请求定义如下: 安全性保证选举限制在任何基于 Leader 的一致性算法中，Leader 都必须存储所有已经提交的日志条目。在某些一致性算法中，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为 Leader。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的 Leader。但这种方式会带来很大的复杂性。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的 Leader 中，不需要传送这些日志条目给 Leader。这意味着日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。 Raft 使用投票的方式来阻止一个 Candidate 赢得选举除非这个 Candidate 包含了所有已经提交的日志条目。如果 Candidate 的日志至少和大多数的服务器节点一样新 或 比他们更新，那么他一定持有了所有已经提交的日志条目。请求投票 RPC(RequestVote RPC) 实现了这样的限制： RPC 中包含了 Candidate 的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。(根据 term、lastLogTerm、lastLogIndex 来判断, 可参考上文选举过程的流程图) Leader 只允许提交自己任期内的日志下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目(2)，也依然有可能会被未来的 Leader 覆盖掉。 一开始如 (a) 所示，之后 S1 下线，(b) 中 S5 从 S3 和 S4 处获得了投票成为了 Leader 并收到了一条来自客户端的消息，之后 S5 下线。(c) 中 S1 恢复并成为了 Leader (Term=4)，并且将日志复制到了多数节点，此时， 如果没有 Leader 提交的任期限制，则 S1 在任期 4 下提交了任期 2 的内容(此时, 用户可见), 然后 S1 下线。(d1) 中 S5 恢复，并从 S2、S3、S4 处获得了足够投票，然后覆盖了他们在索引 2 处的日志，再提交日志(此时,对于用户来说就产生了前后不一致的问题)。另一种遵守 Leader 提交任期限制的情况如(d2)所示, 在任期 4 时提交日志时, 顺带着提交了任期 2，此时, S5 不可能成为 Leader(因为 S1、S2、S3 的任期都比它大), 对于用户来说, 就只会见到一种状态, 保证了一致性。","categories":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"},{"name":"Raft","slug":"分布式算法/Raft","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/Raft/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"http://yoursite.com/tags/Raft/"},{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Git 多次提交记录优化显示","slug":"Git 多次提交记录优化显示","date":"2021-04-11T08:27:45.000Z","updated":"2021-04-11T10:11:46.047Z","comments":true,"path":"2021/04/11/Git 多次提交记录优化显示/","link":"","permalink":"http://yoursite.com/2021/04/11/Git%20%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E4%BC%98%E5%8C%96%E6%98%BE%E7%A4%BA/","excerpt":"写这篇文章的目的, 是为了记录下如何解决Git多次提交记录聚合展示的方法。因为一个功能点的开发包括开发,测试等多个环节, 难免就会导致提交很多次commit, 而为了提交记录看起来更清晰, 且和功能点更好对应, 把这些相同目的的commit合并为一个就显得比较有意义了。当然, 也顺便治一下自己的强迫症。","text":"写这篇文章的目的, 是为了记录下如何解决Git多次提交记录聚合展示的方法。因为一个功能点的开发包括开发,测试等多个环节, 难免就会导致提交很多次commit, 而为了提交记录看起来更清晰, 且和功能点更好对应, 把这些相同目的的commit合并为一个就显得比较有意义了。当然, 也顺便治一下自己的强迫症。 查看提交记录1git log --pretty=oneline 选取要合并的commit执行完上面的命令, 我们看到以下的提交记录: 1234fea1d93fa84e112c2b7314db66b5a66a962e2166 fix: 修复模块xxxbug: bbb98f2a41ea1bd6c0d5843f49480fd7d371f106b13 fix: 修复模块xxxbug: aaa 7ab4333e2e26b9109cb580bff88de4b0373976b3 feat: 新增功能模块xxx57654061b4a3808e04f5a4f6300b78c94048be23 fix: 线上接口超时bug修复 假设我们是想 fea1d93f、98f2a41e、7ab4333e 这3个commit, 作为新的模块xxx的提交记录。此处, 我们选取57654061作为聚合点(该commit之前的都需要被合并)。 合并commit执行以下命令: 1git rebase -i 57654061 此处的commit 57654061 为 7ab4333e 的前一次提交。 执行完上述命令后, 会出现以下一个commit列表, 我们需要从中选取要保留的commit: 12345pick 7ab4333e feat: 新增功能模块xxxpick 98f2a41e fix: 修复模块xxxbug: aaapick fea1d93f fix: 修复模块xxxbug: bbb# ... 编辑为下面所示, 将选取commit以外的行前面的pick改为squash or s, 然后输入: wq 保存退出。 12345pick 7ab4333e feat: 新增功能模块xxxs 98f2a41e fix: 修复模块xxxbug: aaas fea1d93f fix: 修复模块xxxbug: bbb# ... 若无冲突 or 冲突已 fix, 会出现一个commit message的编辑页面, 修改commit message, 然后输入: wq 保存退出。 1234feat: 新增功能模块xxx# 修复模块xxxbug: aaa# 修复模块xxxbug: bbb 若存在冲突, 则需要解决, 保留最新的记录, 输入命令: 12git add .git rebase --continue 若想放弃此次commit合并, 输入命令: 1git rebase --abort 强制提交commit massage 修改完成后, 提交commit, 输入git push -f or git push --force即可。 注意: 上述操作的前提是在非master分支, 建议开发新feature的时候在非master分支, 最终上线才合并到master 如果是master分支, 即便有master分支的提交权限, 也是不允许直接强制提交的(Gitlab), 需要去Git Repository的设置中(Protected Branches)开启","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"工具/Git","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Prestodb 日期和事件函数大全","slug":"Prestodb 日期和事件函数大全","date":"2021-01-17T07:02:45.000Z","updated":"2021-01-22T03:04:55.525Z","comments":true,"path":"2021/01/17/Prestodb 日期和事件函数大全/","link":"","permalink":"http://yoursite.com/2021/01/17/Prestodb%20%E6%97%A5%E6%9C%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/","excerpt":"在工作中, 我们会用到很多日期和时间处理的函数, 这里我们为了方便, 来做一个使用总结, 不用每次都去查Google。","text":"在工作中, 我们会用到很多日期和时间处理的函数, 这里我们为了方便, 来做一个使用总结, 不用每次都去查Google。 日期和时间操作 操作符 示例 结果 + date ‘2012-08-08’ + interval ‘2’ day 2012-08-10 + time ‘01:00’ + interval ‘3’ hour 04:00:00.000 + timestamp ‘2012-08-08 01:00’ + interval ‘29’ hour 2012-08-09 06:00:00.000 + timestamp ‘2012-10-31 01:00’ + interval ‘1’ month 2012-11-30 01:00:00.000 + interval ‘2’ day + interval ‘3’ hour 2 03:00:00.000 + interval ‘3’ year + interval ‘5’ month 3-5 - date ‘2012-08-08’ - interval ‘2’ day 2012-08-06 - time ‘01:00’ - interval ‘3’ hour 22:00:00.000 - timestamp ‘2012-08-08 01:00’ - interval ‘29’ hour 2012-08-06 20:00:00.000 - timestamp ‘2012-10-31 01:00’ - interval ‘1’ month 2012-09-30 01:00:00.000 - interval ‘2’ day - interval ‘3’ hour 1 21:00:00.000 - interval ‘3’ year - interval ‘5’ month 2-7 当前日期、时间函数 current_date -&gt; date返回当前日期。 12select current_date-- 2021-01-17 current_time -&gt; time返回当前时间(含时区)。 1234select current_time-- 23:52:04.371 Asia/Shanghai-- 这个结果看起来有点问题, 因为我执行该条命令的真实时间为 15:52:04.371 Asia/Shanghai-- 可能是公司的Presto的时区设置有问题 current_timestamp -&gt; timestamp返回当前的日期和时间(含时区)。 123select current_timestamp-- 2021-01-17 15:44:43.041 Asia/Shanghai-- 和上面的比, 这条就正常了 current_timezone() -&gt; varchar返回当前时区。 12select current_timestamp-- Asia/Shanghai now() -&gt; timestamp返回当前的日期和时间(含时区)。 12select now()-- 2021-01-17 15:44:43.041 Asia/Shanghai localtime -&gt; time返回当前的时间 123select localtime-- 23:52:04.371-- 遇到了和 current_time 一样的问题 localtimestamp -&gt; timestamp返回当前的日期和时间 12select localtimestamp-- 2021-01-17 15:52:04.371 格式转换 date(x) -&gt; date1select date(&#39;2012-08-10&#39;) 等价于 CAST(x AS date)。x 的两侧有空格 或者 x=’2012-8-10’ 都是可以正常转换的。 日期维度函数 按年 按月 按季度 按周 按天 时间函数时间格式转换时间加/减","categories":[{"name":"函数大全","slug":"函数大全","permalink":"http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/"},{"name":"Prestodb","slug":"函数大全/Prestodb","permalink":"http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/Prestodb/"}],"tags":[{"name":"Prestodb","slug":"Prestodb","permalink":"http://yoursite.com/tags/Prestodb/"}]},{"title":"MySQL-索引","slug":"mysql-索引","date":"2021-01-15T14:02:45.000Z","updated":"2021-01-15T14:31:18.031Z","comments":true,"path":"2021/01/15/mysql-索引/","link":"","permalink":"http://yoursite.com/2021/01/15/mysql-%E7%B4%A2%E5%BC%95/","excerpt":"索引(在MySQL中也叫做”键(key)”) 是排好序的, 用于快速查找数据的一种数据结构。 索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。在数据量较小且负载较低时, 不恰当的索引对性能的可能还不明显，但当数据量逐渐增大时, 性能则会急剧下降。","text":"索引(在MySQL中也叫做”键(key)”) 是排好序的, 用于快速查找数据的一种数据结构。 索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。在数据量较小且负载较低时, 不恰当的索引对性能的可能还不明显，但当数据量逐渐增大时, 性能则会急剧下降。 索引的分类 Hash索引","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"1. MySQL-explain使用说明","slug":"mysql-explain关键字","date":"2021-01-15T14:02:45.000Z","updated":"2021-01-25T02:01:36.314Z","comments":true,"path":"2021/01/15/mysql-explain关键字/","link":"","permalink":"http://yoursite.com/2021/01/15/mysql-explain%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"explain可以查看SQL语句的执行计划。下面, 我们就对explain查询出来的字段做一些使用说明。返回的信息有10列, 分别是:","text":"explain可以查看SQL语句的执行计划。下面, 我们就对explain查询出来的字段做一些使用说明。返回的信息有10列, 分别是: id select_type table type possible_keys key key_len ref rows filtered Extra idid表示查询执行的顺序, 有以下规则: id相同时，由上到下执行 id不同时，id大的先执行 id号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。 select_type 列: 值 含义 SIMPLE 不包含子查询或是UNION操作的查询 PRIMARY 查询中如果包含任何子查询,那么最外层的查询则被标记为PRIMARY SUBQUERY 在SELECT或WHERE列表中包含了子查询 DEPENDENT SUBQUERY 依赖外部结果的子查询 DERIVED 出现在FROM子句中的子查询会被标记为DERIVED(衍生),MySQL会递归执行这些子查询,把结果放在临时表里 UNION 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层的SELECT将被标记为: DERIVED DEPENDENT UNION 当union作为子查询时,第二或是第二个后的查询的select_type值 UNION RESULT 从UNION表获取结果的SELECT 衍生表的优化: https://dev.mysql.com/doc/refman/5.6/en/derived-table-optimization.html table 列: 指明是从哪个表中获取数据 值 含义 &lt;unionM,N&gt; 由ID为M,N查询union产生的结果集 &lt;derived N&gt;/&lt;subquery N&gt; 由ID为N的查询产生的结果集 partitions 列: 对于分区表, 显示查询的分区ID; 非分区表, 显示为NULL type 列: 访问类型, 表示找到所查询数据的方法。性能由好到差: 值 含义 system/const 表中有且只有一个匹配的行时使用, 如对主键(primary key)或是唯一索引(unique index)的查询, 这是效率最高的连接方式。system是const的一种特殊情况,既表本身只有一行数据的情况。 eq_ref 根据唯一索引或者主键查找, 对于每个索引键, 表中只有一条记录与之匹配。 ref 非唯一索引查找, 返回匹配某个单独值的所有行。 ref_or_null 类似于ref类型的查询,但是附加了对NULL值列的查询 index_merge 该连接查询表示使用了索引合并优化方法。 range 索引范围扫描, 常见于between、&gt;、&lt; 这样的查询条件 index full index scan 全索引扫描, 同ALL的区别是, 遍历的是索引树 all full table scan 全表扫描, 这是效率最差的连接方式 system const eq_ref ref ref_or_null index_merge range index all possible_keys: 表示此次查询中可能使用的索引。 key: 表示实际在此次查询中使用的索引。 key_len: 表示实际使用的索引的最大长度。复合索引可能为部分列(根据查询条件)长度之和。该值越小越好。 如何计算key_len 1. 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 2. 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 3. varchar 这种动态字符串要加 2 个字节 4. 允许为空的字段要加 1 个字节 ref: 表示哪些列或常量被用于索引查找, 即连接查询的条件。 rows: 根据统计信息预估的扫描的行数 filtered: 表示返回结果的行数占需读取行数的百分比, 该值越高, 说明性能越好。 extra: 表示查询的其他信息: 值 含义 Distinct 优化distinct操作,在找到第一匹配的元组后即停止找同样值的动作 Not exists 使用not exists来优化查询 Using filesort 说明MySQL会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取。MySQL无法利用索引完成的排序操作称为”文件排序” Using temporary MySQL需要使用临时表来处理查询, 常见于order by,sub_query和group by Using index 使用覆盖索引(Covering index)来进行查询，避免访问表的数据行。如果同时出现Using where，表明索引被用来执行索引键值的查找;如果没有Using where，表明索引用来读取数据而非执行查找动作。 Using where 使用where条件来过滤数据 Using join buffer 使用了连接缓存 impossible where where子句的值总是false，不能用来获取任何元组 select tables optimized away 直接通过索引来获得数据, 不用访问表(MyISAM引擎优化)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL 小技巧","slug":"mysql-tips","date":"2020-11-29T15:27:45.000Z","updated":"2020-11-30T01:00:11.902Z","comments":true,"path":"2020/11/29/mysql-tips/","link":"","permalink":"http://yoursite.com/2020/11/29/mysql-tips/","excerpt":"接下来一段时间, 会将主要精力投入在SQL优化 以及工作中常用的一些SQL小技巧总结。当然啦, 也会对Hive、Spark SQL 和 Presto 中的SQL使用做一些总结。之前SQL写得比较少, 更多的是用的pyspark进行大数据处理, 后端服务更多的用Mybatis自动生成工具来生成DAO层SQL代码,然后在Service层进行多次调用, 一是因为业务逻辑不复杂, 二是因为性能要求也没那么高。不过, 总感觉SQL这块如果不掌握的话, 可能后面发展会受限。好了, 废话不多说, 我们开始一段时间的 SQL 之旅吧。","text":"接下来一段时间, 会将主要精力投入在SQL优化 以及工作中常用的一些SQL小技巧总结。当然啦, 也会对Hive、Spark SQL 和 Presto 中的SQL使用做一些总结。之前SQL写得比较少, 更多的是用的pyspark进行大数据处理, 后端服务更多的用Mybatis自动生成工具来生成DAO层SQL代码,然后在Service层进行多次调用, 一是因为业务逻辑不复杂, 二是因为性能要求也没那么高。不过, 总感觉SQL这块如果不掌握的话, 可能后面发展会受限。好了, 废话不多说, 我们开始一段时间的 SQL 之旅吧。 实验数据表1. user: 表2. job: 表3. sports_duration: 1. 如何在MySQL中使用full join?场景: 将上面的user 表和 job表 合成一张大表。 full join 就是取两者的并集, 而MySQL中是不能使用full join 的, 下面来说下解决方法:使用表user left join 表job, 然后 union all 表user right join 表job(其实也就是表job left join 表user)即可, union all 就是两者的并集。 sql 如下: 123select u.name, u.age, u.hobby, j.name as jname, j.job from user u left JOIN job j on u.`name` = j.nameUNION allselect u.name, u.age, u.hobby, j.name as jname, j.job from user u right JOIN job j on u.`name` = j.name; 结果如下： 通过上图, 我们也可以很清楚的看到 left join 和 right join 后的效果。user left join job 就是user 表作为主表, 将 job 表中与 user表有关联关系的数据作为补充, 详见 上图 left join 红框。另外, 通过指定 where jname is null, 我们也可以取到 user 表中有而 job 表中不存在的用户。right join 同理, 这里就不赘述了。 2. 如何更新使用过滤条件中包括自身的表？场景: 把同时存在于 user表 和 job表的记录的用户在user 表中的age 字段更新为30。错误示例： 1update user set age=30 where user.name in (select j.name from user u join job j on u.name=j.name); 报错： 12update user set age&#x3D;30 where user.name in (select j.name from user u join job j on u.name&#x3D;j.name)&gt; 1093 - You can&#39;t specify target table &#39;user&#39; for update in FROM clause 说明： MySQL 中不支持这样操作, 在 SQLServer 或者 Oracle中可以正常执行。 正确解法: 1update user u join (select j.name from user u join job j on u.name=j.name) j on a.name=j.name set u.age=30; 更新结果如下: 3. 如何使用 join 来优化子查询?先看下面这个带有子查询的sql: 1select u.name, u.age, u.hobby, (select job from job where job.name = u.name ) as job from user u; 使用 join 优化: 1select u.name, u.age, u.hobby, job from user u left join job j on u.`name` = j.`name`; 4. 使用join来优化聚合子查询场景: 找出user 表中三人, 各自运动时长最长的日期。新增表 sports_duration, duration 为运动时长, 单位: 分钟 聚合子查询: 12345select u.name, s.day, s.duration from user u join sports_duration s on u.name=s.name where s.duration=( select max(c.duration) from sports_duration c where c.name=s.name) 结果如下: 使用join优化后, 避免子查询: 12345select u.name, s.day, s.duration from user u join sports_duration s on u.name=s.namejoin sports_duration c on c.name=s.name group by u.name,s.day,s.durationhaving s.duration=max(c.duration); 返回的结果集是相同的。 5. 如何实现分组选择?在 Oracle、SQLServer、PgSQL中可以使用分区查询函数实现: 12345with tmp as ( select u.name, s.day, s.duration, row_number() over(partition by u.name order by s.duration) cnt from user u join sports_duration s on u.name = s.name) select * from tmp where cnt &lt;= 2; 但是, 在 MySQL中不支持。 我们可以这样做: 12345select u.name, d.day, d.duration from ( select name, day, duration, (select count(*) from sports_duration s where s.name=c.name and c.duration &lt;= s.duration) as cnt from sports_duration c group by name, day, duration) d join user u on d.name = u.namewhere cnt &lt;= 2; 结果如下: 下面我们来拆分这个SQL: 1234select u.name, d.day, d.duration, cnt from ( select name, day, duration, (select count(*) from sports_duration s where s.name=c.name and c.duration &lt;= s.duration) as cnt from sports_duration c group by name, day, duration) d join user u on d.name = u.name; 去掉 where条件, 加上返回 cnt 字段, 就可以很清晰的看到明白这个sql的逻辑了, 结果如下图:利用子查询中统计出用户运动耗时大于等于当前运动记录的条数, 然后再进行过滤。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"正则表达式学习","slug":"正则表达式学习","date":"2020-10-03T14:31:45.000Z","updated":"2020-10-08T15:56:29.334Z","comments":true,"path":"2020/10/03/正则表达式学习/","link":"","permalink":"http://yoursite.com/2020/10/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"table th:nth-of-type(1){ width: 17%; } table th:nth-of-type(2){ width: 83%; } 正则示例 正则表达式 描述 this is text 匹配字符串 “this is text” this\\s+is\\s+text 注意字符串中的 \\s+。匹配单词 “this” 后面的 \\s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \\s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text ^\\d+(.\\d+)? ^ 定义了以什么开始; \\d+ 匹配一个或多个数字; ? 设置括号内的选项是可选的; . 匹配 “.”; 可以匹配的实例：”5”, “1.5” 和 “2.21”。","text":"table th:nth-of-type(1){ width: 17%; } table th:nth-of-type(2){ width: 83%; } 正则示例 正则表达式 描述 this is text 匹配字符串 “this is text” this\\s+is\\s+text 注意字符串中的 \\s+。匹配单词 “this” 后面的 \\s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \\s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text ^\\d+(.\\d+)? ^ 定义了以什么开始; \\d+ 匹配一个或多个数字; ? 设置括号内的选项是可选的; . 匹配 “.”; 可以匹配的实例：”5”, “1.5” 和 “2.21”。 java中的正则java.util.regex 包主要包括以下三个类： Pattern 类：Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 matches() 尝试将整个字符串序列与该模式匹配 find() 该方法扫码输入的序列, 查找与该模式匹配的下一个子序列12345678910Pattern PATTERN &#x3D; Pattern.compile(&quot;\\\\d+ \\\\w+&quot;);Matcher matcher &#x3D; PATTERN.matcher(&quot;1 apple&quot;);boolean find &#x3D; matcher.find();System.out.println(&quot;find:&quot; + find);boolean find1 &#x3D; matcher.find();System.out.println(&quot;find1:&quot; + find1);&#x2F;&#x2F; outputfind:truefind1:false group() 捕获组取值, 一般与find() 一起用 group(num) 捕获组取值, 一般与matches() 一起用 PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 一般是两种用途: 判断字符串中是否包含某个子串; 提取某个字符串中符合正则规则的内容 注: 正则中的 \\ 在Java中需要使用 \\\\ 正则表达式-匹配字符(集合) 匹配普通字符:字母、数字、汉字、下划线, 以及没有特殊定义的标点符号 匹配转义字符 字符 说明 \\n 代表换行符 \\t 制表符 \\、^、$、(、)、{、}、?、+、*、\\、|、[、] 代表字符本身(就是在正则表达式中有特殊作用的字符需要做转义处理) 标准字符集合 字符 说明 \\d 数字字符匹配。等效于 [0-9] \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式 自定义字符集合[] 方括号匹配方式, 能够匹配方括号中的任意一个字符。 字符集合 说明 [ab5@] 匹配 a 或 b 或 5 或 @ [^abc] 匹配 a、 b、 c之外的任意一个字符 [a-z] 匹配 a~z 之间的任意一个字符 [^A-F0-3] 匹配 AF, 03 之外的任意一个字符 注意: 正则表达式的特殊符号, 被包含到中括号中, 则失去特殊意义, 除了 ^ 和 - 之外 标准字符集合, 除小数点外, 如果被包含于中括号中, 自定义字符集合将包含该集合, 比如: [\\d.-+] 将匹配: 数字 或 小数点 或 + 或 - 量词 修饰匹配次数的特殊符号。 字符 说明 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 匹配表达式0次或1次, 相当于 {0,1} + 表达式至少出现一次, 相当于 {1,} * 表达式不出现或者出现任意次, 相当于{0,} 注: {0,1} 中逗号左边必须有, 不能有 {,6} 这种形式 匹配规则默认为贪婪模式, 即匹配字符越多越好 匹配次数中的非贪婪模式(匹配字符越少越好, 修饰匹配次数的特殊符合后再加一个 ?) 字符边界 匹配符合某种条件的位置 字符 说明 ^ 字符串开始的地方进行匹配([]外) $ 字符串结束的地方进行匹配 \\b 匹配一个单次边界，即前面或后面的字符至少有一个是[A-Za-z0-9_]以外的字符 ^A 多行模式下, 匹配第一个出现的字符 ^Z 多行模式下, 匹配最后一个出现的字符 选择符和分组 字符 作用 | 或 () 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“ 反向引用 每一对 ()会分配一个编号, 使用 () 的捕获根据左括号的顺序从1开始自动编号 通过反向引用, 可以对已捕获的字符串进行引用","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"正则表达式","slug":"其他/正则表达式","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Azkaban-1.搭建Azkaban源代码阅读环境","slug":"Azkaban-1.搭建Azkaban源代码阅读环境","date":"2020-05-23T08:26:45.000Z","updated":"2020-10-08T15:52:27.640Z","comments":true,"path":"2020/05/23/Azkaban-1.搭建Azkaban源代码阅读环境/","link":"","permalink":"http://yoursite.com/2020/05/23/Azkaban-1.%E6%90%AD%E5%BB%BAAzkaban%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/","excerpt":"在公司的日常工作中， 经常会用到 Azkaban。作为一种工作流管理系统, 对我来说, 的确有学习的价值。 本文将会使用最新版的Azkaban源代码, 编译并搭建一套可运行调试的系统。开发工具使用的是IDEA, 运行环境是CentOS7。 从github下载源代码截止目前，最新的tag版本是: 3.86.0可以直接点击下载源码: 3.86.0","text":"在公司的日常工作中， 经常会用到 Azkaban。作为一种工作流管理系统, 对我来说, 的确有学习的价值。 本文将会使用最新版的Azkaban源代码, 编译并搭建一套可运行调试的系统。开发工具使用的是IDEA, 运行环境是CentOS7。 从github下载源代码截止目前，最新的tag版本是: 3.86.0可以直接点击下载源码: 3.86.0 编译用IDEA打开, File -&gt; Open… -&gt; 选择已解压的代码目录 -&gt; 点击 OK。此时, IDEA会自动同步一些Gradle项目的配置，稍微等待一会。 为了解决gradle项目下载依赖慢的问题， 我们可以加上阿里云的maven仓库地址。在azkaban根目录下的 build.gradle 中加入下面内容即可: 1maven &#123; url \"http://maven.aliyun.com/nexus/content/groups/public\" &#125; 加入后的效果是这样的: 123456789allprojects &#123; apply plugin: &#39;jacoco&#39; repositories &#123; maven &#123; url &quot;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&quot; &#125; mavenCentral() mavenLocal() &#125;&#125; 注意: 这里需要保留原来的仓库地址, 因为有些依赖阿里云仓库下载不到 再配置一个 npm的淘宝源, 毕竟国外的不太稳定。在用户目录下, 创建 .npmrc 文件: 1vi ~&#x2F;.npmrc 再加入以下内容即可: 1registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 配置好之后, 我们就可以执行以下命令编译了: 1./gradlew build -x test 编译成功后, 就有了az-web 和 az-exec 的可运行程序压缩包了。 数据库、表初始化推荐使用 MySQL5.7.x 12345678-- 创建数据库mysql&gt; CREATE DATABASE azkaban;--创建用户, username/password 自定义mysql&gt; CREATE USER 'username'@'%' IDENTIFIED BY 'password';--授权, &lt;username&gt; 改为你自己的用户名 mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE ON azkaban.* to '&lt;username&gt;'@'%' WITH GRANT OPTION; 调整Mysql Packet Size, 找到MySQL的配置文件,修改max_allowed_packet=1024M 123[mysqld]...max_allowed_packet&#x3D;1024M 重启MySQL 1sudo &#x2F;sbin&#x2F;service mysqld restart 使用初始化sql建表: 12# 位置azkaban-3.86.0\\azkaban-db\\build\\sql\\create-all-sql-0.1.0-SNAPSHOT.sql 运行azkaban Exec节点编译后的压缩包路径: azkaban-exec-server/build/distributions/azkaban-exec-server-0.1.0-SNAPSHOT.zip 1.更改配置文件上传 azkaban-exec-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-exec-server/conf/azkaban.properties 配置文件: 123456789101112131415# 数据库信息mysql.port=3306mysql.host=192.168.3.25mysql.database=azkabanmysql.user=rootmysql.password=123456# 执行节点信息executor.port=12321azkaban.use.multiple.executors=trueazkaban.executorselector.filters=StaticRemainingFlowSize,MinimumFreeMemory,CpuStatusazkaban.executorselector.comparator.NumberOfAssignedFlowComparator=1azkaban.executorselector.comparator.Memory=1azkaban.executorselector.comparator.LastDispatched=1azkaban.executorselector.comparator.CpuUsage=1 2.设置远程debug2.1 编辑文件 azkaban-exec-server/bin/internal/internal-start-executor.sh， 增加一个 AZKABAN_OPTS 值 123......AZKABAN_OPTS=\"$AZKABAN_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5554\"java $AZKABAN_OPTS $JAVA_LIB_PATH -cp $CLASSPATH azkaban.execapp.AzkabanExecutorServer -conf $conf $@ &amp; 2.2 IDEA中配置点击编辑运行时配置 -&gt; 点击左上角的 + ，选择 Remote 选项。配置如下图:说明: Host: 为az执行节点的IP Port: 为 上面我们配置的那个远程debug端口 Use module classpath: 为az-exec模块的main 点击OK即可, 需要远程服务先启动,才能进行远程debug操作。 3.运行并激活az-exec运行: 12cd azkaban-exec-serverbin/start-exec.sh 激活: 1curl -G &quot;http:&#x2F;&#x2F;192.168.3.25:12321&#x2F;executor?action&#x3D;activate&quot; &amp;&amp; echo 192.168.3.25:12321 为 az执行节点的地址 此时, 可以发现azkaban库 executors 表中已经有执行节点的记录 运行azkaban Web节点编译后的压缩包路径:azkaban-web-server/build/distributions/azkaban-web-server-0.1.0-SNAPSHOT.zip 1.更改配置文件上传 azkaban-web-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-web-server/conf/azkaban.properties 配置文件: 123456# 数据库信息mysql.port=3306mysql.host=192.168.3.25mysql.database=azkabanmysql.user=rootmysql.password=123456 2.设置远程debug2.1 编辑文件 azkaban-web-server/bin/internal/internal-start-web.sh， 增加一个 AZKABAN_OPTS 值 123......AZKABAN_OPTS=\"$AZKABAN_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555\"java $AZKABAN_OPTS $JAVA_LIB_PATH -cp $CLASSPATH azkaban.webapp.AzkabanWebServer -conf $conf $@ &amp; 2.2 IDEA中配置点击编辑运行时配置 -&gt; 点击左上角的 + ，选择 Remote 选项。配置如下图: 3.运行az-web 12cd azkaban-web-serverbin/start-web.sh 4.登录Azkaban默认使用的xml来管理用户。配置文件目录: azkaban-web-server/conf/azkaban-users.xml访问 http://192.168.3.25:8081, 使用azkaban/azkaban 即可登录。 192.168.3.25: 为 az-web的ip 8081: 为az-web的端口 远程调试在 az-web 和 az-exec 都启动之后, 先确保所有端口都能正常访问, 我这儿配置的是 az-exec服务端口: 12321 az-exec远程debug端口: 5554 az-web服务端口: 8091 az-web远程debug端口: 5555 然后在IDEA中运行下图中的这两项即可。在想要看细节的地方打上断点, 就可以愉快玩耍啦。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"IDEA","slug":"工具/IDEA","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/IDEA/"}],"tags":[{"name":"Azkaban","slug":"Azkaban","permalink":"http://yoursite.com/tags/Azkaban/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"},{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"},{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}],"categories":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"},{"name":"Raft","slug":"分布式算法/Raft","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/Raft/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"工具/Git","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Git/"},{"name":"函数大全","slug":"函数大全","permalink":"http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/"},{"name":"Prestodb","slug":"函数大全/Prestodb","permalink":"http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/Prestodb/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"正则表达式","slug":"其他/正则表达式","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"IDEA","slug":"工具/IDEA","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/IDEA/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"http://yoursite.com/tags/Raft/"},{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Prestodb","slug":"Prestodb","permalink":"http://yoursite.com/tags/Prestodb/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"Azkaban","slug":"Azkaban","permalink":"http://yoursite.com/tags/Azkaban/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"},{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"},{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}