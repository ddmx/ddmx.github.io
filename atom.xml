<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matthew Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-05T09:47:45.930Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Matthew</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式共识算法Raft</title>
    <link href="http://yoursite.com/2022/03/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft/"/>
    <id>http://yoursite.com/2022/03/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft/</id>
    <published>2022-03-05T03:51:00.000Z</published>
    <updated>2022-03-05T09:47:45.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Raft-诞生"><a href="#Raft-诞生" class="headerlink" title="Raft 诞生"></a>Raft 诞生</h3><p>2013 年, 斯坦福大学的 Diego Ongaro 和 John Ousterhout 发表了 Raft 论文<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14.pdf" target="_blank" rel="noopener">《In Search of an Understanding Consensus Algorithm》</a>,但是这篇论文比较短小,只是简单介绍了一下原理,对一些实现细节部分没有提及。更详细的论文是 Diego Ongaro 的博士论文<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwcl.cs.rpi.edu%2Fpilots%2Flibrary%2Fpapers%2Fconsensus%2FRAFTOngaroPhD.pdf">《CONSENSUS: BRIDGING THEORY AND PRACTICE》</a>。<code>Raft</code>的产生就是为了代替 <code>Paxos</code>, 毕竟 <code>Paxos</code>算法自 1990 年诞生以来，就一直被诟病难以理解,这也导致了后面业界很多基于<code>Paxos</code>的实现都是”Paxos-like”实现。</p><a id="more"></a><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="共识-amp-一致性"><a href="#共识-amp-一致性" class="headerlink" title="共识 &amp; 一致性"></a>共识 &amp; 一致性</h4><p>共识（Consensus）很多时候会与一致性（Consistency）放在一起讨论。严谨地讲，两者的含义并不完全相同。一致性的含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。具体到分布式系统场景下，一致性指的是多个副本对外呈现的状态。如前面提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。而共识，则特指在分布式系统中多个节点之间对某个事情（例如多个事务请求，先执行谁？）达成一致观点的过程。因此，达成某种共识并不意味着就保障了一致性。</p><h4 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h4><p>拜占庭问题（Byzantine Problem）又叫拜占庭将军（Byzantine Generals Problem）问题，讨论的是在少数节点有可能作恶（消息可能被伪造）的场景下，如何达成共识问题。 Raft 集群内的节点都对选举出的 Leader 采取信任, 因此, Raft 算法并不是一种拜占庭容错算法。</p><h4 id="复制机状态机"><a href="#复制机状态机" class="headerlink" title="复制机状态机"></a>复制机状态机</h4><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="复制状态机的结构" style="zoom:90%;" /><p>上面是复制状态机架构图。共识算法通常出现在复制状态机的环境中, 也就是上图的 <code>Consensus Module</code>, 它管理着来自客户端的<code>状态机指令</code>的复制日志(Log)。 状态机(State Machine)处理来自日志(Log)的相同指令序列，因此它们产生相同的输出。</p><h3 id="Raft-算法基础"><a href="#Raft-算法基础" class="headerlink" title="Raft 算法基础"></a>Raft 算法基础</h3><p>为了让 Raft 算法更好被人理解, Raft 设计者将一致性问题分解成了三个相对独立的子问题：</p><ul><li>领导者选举：启动集群时或现有领导者异常时必须选出新的领导者。</li><li>日志复制：领导者接收来自客户端的日志条目，并在整个集群中复制它们，迫使其他节点的日志与自己的一致。</li><li>安全性：Raft 的安全属性的关键是状态机安全性属性：如果任一个节点已将特定的日志条目应用于其状态机，则其他节点都不可以对同一日志索引应用不同的指令。Raft 通过选举机制的额外限制以及 Leader 日志提交的任期限制来保证这一特性。</li></ul><h4 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h4><h5 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h5><p>集群中的节点主要有以下三者状态:</p><ul><li>Leader (领导者): 处理与客户端的交互和与 Follower 的日志复制等，正常情况下只有一个 Leader</li><li>Follower (追随者): 被动从 Leader 同步日志，同时也会在 Leader 超时后转变为 Candidate 参与竞选，正常情况<br>下集群中除了 Leader 之外都是 Follower</li><li>Candidate (候选者): 在竞选期间参与竞选</li></ul><p>不同状态的节点之间会发生下图所示的一些变化:</p><p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305152805885.png" alt="image-20220305152805885"></p><p>节点的初始状态都是 Follower, 当节点超时(150 ~ 300 ms, 随机), 它会成为 Candidate, 开始竞选 Leader, 当得到大多数选票时, Candidate 会变成 Leader, 否则, 所有节点会再次进入倒计时状态, 重复这个过程, 直到选出 Leader。Leader 选出后, 会周期性地向其他节点发送心跳请求, 避免新的 Leader 产生。</p><p>由 Candidate 发往其他节点的请求投票 RPC(<code>RequestVote RPC</code>) 的定义如下:</p><p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305170317787.png" alt="image-20220305170317787"></p><h5 id="任期-Term"><a href="#任期-Term" class="headerlink" title="任期(Term)"></a>任期(Term)</h5><p>Leader 的选举引出了一个新的概念——任期（Term）。</p><p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BB%BB%E6%9C%9F.png" alt="任期"></p><ul><li>时间被划分成一个个的任期，任期用连续单调递增的整数标记，每个任期开始都是一次选举</li><li>在选举成功后，Leader 会管理整个集群直到任期结束 (一个任期最多只会产生一个 Leader)</li><li>有时候选举会失败，那么这个任期就会没有 Leader 而结束, 如上图的 t3</li><li>当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，那么他会更新自己的编号到较大的编号值。如果 Leader 或者 Candidate 发现自己的任期号过期了，那么他会立即恢复成 Follower。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</li></ul><h5 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h5><p>要开始一次选举过程, Follower 要先增加自己当前的任期号(Term)并且转换到 Candidate 状态。他会先给自己投一票, 然后并行的向集群中的其他服务器节点发送拉票请求。其他节点在收到 Candidate 发送的拉票请求后, 会根据以下规则(Leader 选举限制)判定是同意还是反对，见下图:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/%E6%8A%95%E7%A5%A8%E9%99%90%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="投票限制流程" style="zoom:50%;" /><p>其他节点在收到 Candidate 的拉票请求后的判定逻辑:</p><ol><li>如果当前节点已经给其他节点(根据 candidateId 判定, 也可以是自己)投过票, 则反对</li><li>如果 Candidate 的任期(Term)比当前节点的任期小, 则反对, 并将 Candidate 的任期设置为当前节点的任期</li><li>如果 Candidate 的 lastLogTerm(上一条日志的任期)比当前节点上一条日志的任期小, 则反对</li><li>如果 Candidate 的 lastLogIndex(上一条日志的索引)比当前节点上一条日志的索引小, 则反对</li><li>否则, 当前节点则投票给 Candidate，当前任期内, 不会再投票给其他的 Candidate</li></ol><p>选举的动态图如下，初次选举:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/Leader%E5%88%9D%E6%AC%A1%E9%80%89%E4%B8%BE.gif" alt="Leader初次选举" style="zoom:67%;" /><p>Leader 异常后, 重新选举:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/Leader%E5%86%8D%E6%AC%A1%E9%80%89%E4%B8%BE-Leader%E4%B8%8B%E7%BA%BF.gif" alt="Leader再次选举-Leader下线" style="zoom:67%;" /><h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><h5 id="正常复制"><a href="#正常复制" class="headerlink" title="正常复制"></a>正常复制</h5><p>流程如下图:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6-%E6%AD%A3%E5%B8%B8%E5%A4%8D%E5%88%B6.gif" alt="日志复制-正常复制" style="zoom:67%;" /><p>以 SET 5 为例, 日志复制的流程如下图所示:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305163810532.png" alt="image-20220305163810532" style="zoom: 50%;" /><p>在第一次由 Leader 复制到其他节点时, 并不会立即提交。Leader 提交日志条目的条件是该条目在大多数节点上已经存在。</p><h5 id="日志冲突处理"><a href="#日志冲突处理" class="headerlink" title="日志冲突处理"></a>日志冲突处理</h5><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3.png" alt="日志复制-冲突解决" style="zoom: 67%;" /><p>当一个 Leader 成功当选时:</p><ul><li>Follower 可能会缺少一些日志条目（a-b）</li><li>可能会有一些未被提交的日志条目（c-d）</li><li>或者两种情况都存在（e-f）</li></ul><p>在 Raft 算法中，Leader 是通过强制 Follower 直接复制它的日志来处理不一致问题的。这意味着在 Follower 中冲突的日志条目会被 Leader 的日志所覆盖。</p><p>要使得 Follower 的日志进入和自己一致的状态，Leader 必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行<code>AppendEntries RPC</code>(附加日志条目的 RPC 请求) 的一致性检查时完成。Leader 针对每一个 Follower 维护了一个 nextIndex，这表示下一个需要发送给 Follower 的日志条目的索引地址。当一个 Leader 刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（上图中的 11）。如果一个 Follower 的日志和 Leader 不一致，那么在下一次的<code>AppendEntries RPC</code> 时的一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。当这种情况发生，<code>AppendEntries RPC</code> 就会成功，这时就会把 Follower 冲突的日志条目全部删除并且加上 Leader 的日志。一旦<code>AppendEntries RPC</code> 成功，那么 Follower 的日志就会和 Leader 保持一致，并且在接下来的任期里一直继续保持。</p><p>在 Leader 发现它与 Follower 的日志匹配位置之前，Leader 可以发送不带任何条目（例如心跳）的<code>AppendEntries RPC</code> 以节省带宽。 然后，一旦 matchIndex(其他节点和 Leader 日志一致的索引位置) 恰好比 nextIndex 小 1，则 Leader 应开始发送实际的日志条目。</p><p>Leader 在复制日志时的<code>AppendEntries RPC</code> 请求定义如下:</p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305170726211.png" alt="image-20220305170726211"  /><h3 id="安全性保证"><a href="#安全性保证" class="headerlink" title="安全性保证"></a>安全性保证</h3><h4 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h4><p>在任何基于 Leader 的一致性算法中，Leader 都必须存储所有已经提交的日志条目。在某些一致性算法中，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为 Leader。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的 Leader。但这种方式会带来很大的复杂性。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的 Leader 中，不需要传送这些日志条目给 Leader。这意味着日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止一个 Candidate 赢得选举除非这个 Candidate 包含了所有已经提交的日志条目。如果 Candidate 的日志至少和大多数的服务器节点一样新 或 比他们更新，那么他一定持有了所有已经提交的日志条目。请求投票 RPC(<code>RequestVote RPC</code>) 实现了这样的限制： RPC 中包含了 Candidate 的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。(根据 term、lastLogTerm、lastLogIndex 来判断, 可参考上文选举过程的流程图)</p><h4 id="Leader-只允许提交自己任期内的日志"><a href="#Leader-只允许提交自己任期内的日志" class="headerlink" title="Leader 只允许提交自己任期内的日志"></a>Leader 只允许提交自己任期内的日志</h4><p>下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目(2)，也依然有可能会被未来的 Leader 覆盖掉。</p><p><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/Leader%E5%8F%AA%E5%85%81%E8%AE%B8%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E4%BB%BB%E6%9C%9F%E5%86%85%E7%9A%84%E6%97%A5%E5%BF%97.png" alt="Leader只允许提交自己任期内的日志"></p><p>一开始如 (a) 所示，之后 S1 下线，(b) 中 S5 从 S3 和 S4 处获得了投票成为了 Leader 并收到了一条来自客户端的消息，之后 S5 下线。(c) 中 S1 恢复并成为了 Leader (Term=4)，并且将日志复制到了多数节点，此时， 如果没有 Leader 提交的任期限制，则 S1 在任期 4 下提交了任期 2 的内容(此时, 用户可见), 然后 S1 下线。(d1) 中 S5 恢复，并从 S2、S3、S4 处获得了足够投票，然后覆盖了他们在索引 2 处的日志，再提交日志(此时,对于用户来说就产生了前后不一致的问题)。<br>另一种遵守 Leader 提交任期限制的情况如(d2)所示, 在任期 4 时提交日志时, 顺带着提交了任期 2，此时, S5 不可能成为 Leader(因为 S1、S2、S3 的任期都比它大), 对于用户来说, 就只会见到一种状态, 保证了一致性。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Raft-诞生&quot;&gt;&lt;a href=&quot;#Raft-诞生&quot; class=&quot;headerlink&quot; title=&quot;Raft 诞生&quot;&gt;&lt;/a&gt;Raft 诞生&lt;/h3&gt;&lt;p&gt;2013 年, 斯坦福大学的 Diego Ongaro 和 John Ousterhout 发表了 Raft 论文&lt;a href=&quot;https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《In Search of an Understanding Consensus Algorithm》&lt;/a&gt;,但是这篇论文比较短小,只是简单介绍了一下原理,对一些实现细节部分没有提及。更详细的论文是 Diego Ongaro 的博士论文&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fwcl.cs.rpi.edu%2Fpilots%2Flibrary%2Fpapers%2Fconsensus%2FRAFTOngaroPhD.pdf&quot;&gt;《CONSENSUS: BRIDGING THEORY AND PRACTICE》&lt;/a&gt;。&lt;code&gt;Raft&lt;/code&gt;的产生就是为了代替 &lt;code&gt;Paxos&lt;/code&gt;, 毕竟 &lt;code&gt;Paxos&lt;/code&gt;算法自 1990 年诞生以来，就一直被诟病难以理解,这也导致了后面业界很多基于&lt;code&gt;Paxos&lt;/code&gt;的实现都是”Paxos-like”实现。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式算法" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="Raft" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/Raft/"/>
    
    
    <category term="Raft" scheme="http://yoursite.com/tags/Raft/"/>
    
    <category term="分布式算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Git 多次提交记录优化显示</title>
    <link href="http://yoursite.com/2021/04/11/Git%20%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E4%BC%98%E5%8C%96%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2021/04/11/Git%20%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E4%BC%98%E5%8C%96%E6%98%BE%E7%A4%BA/</id>
    <published>2021-04-11T08:27:45.000Z</published>
    <updated>2021-04-11T10:11:46.047Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的目的, 是为了记录下如何解决Git多次提交记录聚合展示的方法。因为一个功能点的开发包括开发,测试等多个环节, 难免就会导致提交很多次commit, 而为了提交记录看起来更清晰, 且和功能点更好对应, 把这些相同目的的commit合并为一个就显得比较有意义了。当然, 也顺便治一下自己的强迫症。</p><a id="more"></a><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><h4 id="选取要合并的commit"><a href="#选取要合并的commit" class="headerlink" title="选取要合并的commit"></a>选取要合并的commit</h4><p>执行完上面的命令, 我们看到以下的提交记录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fea1d93fa84e112c2b7314db66b5a66a962e2166 fix: 修复模块xxxbug: bbb</span><br><span class="line">98f2a41ea1bd6c0d5843f49480fd7d371f106b13 fix: 修复模块xxxbug: aaa </span><br><span class="line">7ab4333e2e26b9109cb580bff88de4b0373976b3 feat: 新增功能模块xxx</span><br><span class="line">57654061b4a3808e04f5a4f6300b78c94048be23 fix: 线上接口超时bug修复</span><br></pre></td></tr></table></figure><p>假设我们是想 fea1d93f、98f2a41e、7ab4333e 这3个commit, 作为新的模块xxx的提交记录。此处, 我们选取57654061作为聚合点(该commit之前的都需要被合并)。</p><h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><p>执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 57654061</span><br></pre></td></tr></table></figure><p>此处的commit 57654061 为 7ab4333e 的前一次提交。</p><p>执行完上述命令后, 会出现以下一个commit列表, 我们需要从中选取要保留的commit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick 7ab4333e feat: 新增功能模块xxx</span><br><span class="line">pick 98f2a41e fix: 修复模块xxxbug: aaa</span><br><span class="line">pick fea1d93f fix: 修复模块xxxbug: bbb</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>编辑为下面所示, 将选取commit以外的行前面的<code>pick</code>改为<code>squash</code> or <code>s</code>, 然后输入: <code>wq</code> 保存退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick 7ab4333e feat: 新增功能模块xxx</span><br><span class="line">s 98f2a41e fix: 修复模块xxxbug: aaa</span><br><span class="line">s fea1d93f fix: 修复模块xxxbug: bbb</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>若无冲突 or 冲突已 fix, 会出现一个<code>commit message</code>的编辑页面, 修改<code>commit message</code>, 然后输入: <code>wq</code> 保存退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feat: 新增功能模块xxx</span><br><span class="line"></span><br><span class="line"># 修复模块xxxbug: aaa</span><br><span class="line"># 修复模块xxxbug: bbb</span><br></pre></td></tr></table></figure><p>若存在冲突, 则需要解决, 保留最新的记录, 输入命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>若想放弃此次<code>commit</code>合并, 输入命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><h4 id="强制提交"><a href="#强制提交" class="headerlink" title="强制提交"></a>强制提交</h4><p><code>commit massage</code> 修改完成后, 提交<code>commit</code>, 输入<code>git push -f</code> or <code>git push --force</code>即可。</p><blockquote><p>注意: </p><ol><li>上述操作的前提是在非master分支, 建议开发新feature的时候在非master分支, 最终上线才合并到master</li><li>如果是master分支, 即便有master分支的提交权限, 也是不允许直接强制提交的(Gitlab), 需要去Git Repository的设置中(Protected Branches)开启</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;写这篇文章的目的, 是为了记录下如何解决Git多次提交记录聚合展示的方法。因为一个功能点的开发包括开发,测试等多个环节, 难免就会导致提交很多次commit, 而为了提交记录看起来更清晰, 且和功能点更好对应, 把这些相同目的的commit合并为一个就显得比较有意义了。当然, 也顺便治一下自己的强迫症。&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Git/"/>
    
    
    <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Prestodb 日期和事件函数大全</title>
    <link href="http://yoursite.com/2021/01/17/Prestodb%20%E6%97%A5%E6%9C%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2021/01/17/Prestodb%20%E6%97%A5%E6%9C%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/</id>
    <published>2021-01-17T07:02:45.000Z</published>
    <updated>2021-01-22T03:04:55.525Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中, 我们会用到很多日期和时间处理的函数, 这里我们为了方便, 来做一个使用总结, 不用每次都去查Google。</p><a id="more"></a><h3 id="日期和时间操作"><a href="#日期和时间操作" class="headerlink" title="日期和时间操作"></a>日期和时间操作</h3><table><thead><tr><th>操作符</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>date ‘2012-08-08’ + interval ‘2’ day</td><td>2012-08-10</td></tr><tr><td>+</td><td>time ‘01:00’ + interval ‘3’ hour</td><td>04:00:00.000</td></tr><tr><td>+</td><td>timestamp ‘2012-08-08 01:00’ + interval ‘29’ hour</td><td>2012-08-09 06:00:00.000</td></tr><tr><td>+</td><td>timestamp ‘2012-10-31 01:00’ + interval ‘1’ month</td><td>2012-11-30 01:00:00.000</td></tr><tr><td>+</td><td>interval ‘2’ day + interval ‘3’ hour</td><td>2 03:00:00.000</td></tr><tr><td>+</td><td>interval ‘3’ year + interval ‘5’ month</td><td>3-5</td></tr><tr><td>-</td><td>date ‘2012-08-08’ - interval ‘2’ day</td><td>2012-08-06</td></tr><tr><td>-</td><td>time ‘01:00’ - interval ‘3’ hour</td><td>22:00:00.000</td></tr><tr><td>-</td><td>timestamp ‘2012-08-08 01:00’ - interval ‘29’ hour</td><td>2012-08-06 20:00:00.000</td></tr><tr><td>-</td><td>timestamp ‘2012-10-31 01:00’ - interval ‘1’ month</td><td>2012-09-30 01:00:00.000</td></tr><tr><td>-</td><td>interval ‘2’ day - interval ‘3’ hour</td><td>1 21:00:00.000</td></tr><tr><td>-</td><td>interval ‘3’ year - interval ‘5’ month</td><td>2-7</td></tr></tbody></table><h3 id="当前日期、时间函数"><a href="#当前日期、时间函数" class="headerlink" title="当前日期、时间函数"></a>当前日期、时间函数</h3><ul><li><p>current_date -&gt; date<br>返回当前日期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_date</span></span><br><span class="line"><span class="comment">--  2021-01-17</span></span><br></pre></td></tr></table></figure></li><li><p>current_time -&gt; time<br>返回当前时间(含时区)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_time</span></span><br><span class="line"><span class="comment">--  23:52:04.371 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 这个结果看起来有点问题, 因为我执行该条命令的真实时间为 15:52:04.371 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 可能是公司的Presto的时区设置有问题</span></span><br></pre></td></tr></table></figure></li><li><p>current_timestamp -&gt; timestamp<br>返回当前的日期和时间(含时区)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span></span><br><span class="line"><span class="comment">-- 2021-01-17 15:44:43.041 Asia/Shanghai</span></span><br><span class="line"><span class="comment">-- 和上面的比, 这条就正常了</span></span><br></pre></td></tr></table></figure></li><li><p>current_timezone() -&gt; varchar<br>返回当前时区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span></span><br><span class="line"><span class="comment">-- Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li><li><p>now() -&gt; timestamp<br>返回当前的日期和时间(含时区)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>()</span><br><span class="line"><span class="comment">-- 2021-01-17 15:44:43.041 Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li><li><p>localtime -&gt; time<br>返回当前的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">localtime</span></span><br><span class="line"><span class="comment">-- 23:52:04.371</span></span><br><span class="line"><span class="comment">-- 遇到了和 current_time 一样的问题</span></span><br></pre></td></tr></table></figure></li><li><p>localtimestamp -&gt; timestamp<br>返回当前的日期和时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">localtimestamp</span></span><br><span class="line"><span class="comment">-- 2021-01-17 15:52:04.371</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ul><li>date(x) -&gt; date<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select date(&#39;2012-08-10&#39;)</span><br></pre></td></tr></table></figure></li></ul><p>等价于 <code>CAST(x AS date)</code>。x 的两侧有空格 或者 x=’2012-8-10’ 都是可以正常转换的。</p><h4 id="日期维度函数"><a href="#日期维度函数" class="headerlink" title="日期维度函数"></a>日期维度函数</h4><ol><li><p>按年</p></li><li><p>按月</p></li><li><p>按季度</p></li><li><p>按周</p></li><li><p>按天</p></li></ol><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><h4 id="时间格式转换"><a href="#时间格式转换" class="headerlink" title="时间格式转换"></a>时间格式转换</h4><h4 id="时间加-减"><a href="#时间加-减" class="headerlink" title="时间加/减"></a>时间加/减</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;在工作中, 我们会用到很多日期和时间处理的函数, 这里我们为了方便, 来做一个使用总结, 不用每次都去查Google。&lt;/p&gt;</summary>
    
    
    
    <category term="函数大全" scheme="http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/"/>
    
    <category term="Prestodb" scheme="http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/Prestodb/"/>
    
    
    <category term="Prestodb" scheme="http://yoursite.com/tags/Prestodb/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-索引</title>
    <link href="http://yoursite.com/2021/01/15/mysql-%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2021/01/15/mysql-%E7%B4%A2%E5%BC%95/</id>
    <published>2021-01-15T14:02:45.000Z</published>
    <updated>2021-01-15T14:31:18.031Z</updated>
    
    <content type="html"><![CDATA[<p>索引(在MySQL中也叫做”键(key)”) 是排好序的, 用于快速查找数据的一种数据结构。</p><p>索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。<br>在数据量较小且负载较低时, 不恰当的索引对性能的可能还不明显，但当数据量逐渐增大时, 性能则会急剧下降。</p><a id="more"></a><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/mysql-index-category1.png" width="65%" alt="MySQL索引分类"><h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul><li>Hash索引</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;索引(在MySQL中也叫做”键(key)”) 是排好序的, 用于快速查找数据的一种数据结构。&lt;/p&gt;
&lt;p&gt;索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。&lt;br&gt;在数据量较小且负载较低时, 不恰当的索引对性能的可能还不明显，但当数据量逐渐增大时, 性能则会急剧下降。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
    <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>1. MySQL-explain使用说明</title>
    <link href="http://yoursite.com/2021/01/15/mysql-explain%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2021/01/15/mysql-explain%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-01-15T14:02:45.000Z</published>
    <updated>2021-01-25T02:01:36.314Z</updated>
    
    <content type="html"><![CDATA[<p><code>explain</code>可以查看SQL语句的执行计划。下面, 我们就对<code>explain</code>查询出来的字段做一些使用说明。<br>返回的信息有10列, 分别是:</p><a id="more"></a><ul><li>id</li><li>select_type</li><li>table</li><li>type</li><li>possible_keys</li><li>key</li><li>key_len</li><li>ref</li><li>rows</li><li>filtered</li><li>Extra</li></ul><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id表示查询执行的顺序, 有以下规则:</p><ul><li>id相同时，由上到下执行</li><li>id不同时，id大的先执行</li><li>id号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</li></ul><ol start="2"><li>select_type 列:</li></ol><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>不包含子查询或是UNION操作的查询</td></tr><tr><td>PRIMARY</td><td>查询中如果包含任何子查询,那么最外层的查询则被标记为PRIMARY</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>依赖外部结果的子查询</td></tr><tr><td>DERIVED</td><td>出现在FROM子句中的子查询会被标记为DERIVED(衍生),MySQL会递归执行这些子查询,把结果放在临时表里</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层的SELECT将被标记为: DERIVED</td></tr><tr><td>DEPENDENT UNION</td><td>当union作为子查询时,第二或是第二个后的查询的select_type值</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><p>衍生表的优化: <a href="https://dev.mysql.com/doc/refman/5.6/en/derived-table-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/derived-table-optimization.html</a></p><ul><li>table 列: 指明是从哪个表中获取数据</li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>&lt;unionM,N&gt;</code></td><td>由ID为M,N查询union产生的结果集</td></tr><tr><td><code>&lt;derived N&gt;/&lt;subquery N&gt;</code></td><td>由ID为N的查询产生的结果集</td></tr></tbody></table><ul><li><p>partitions 列: 对于分区表, 显示查询的分区ID; 非分区表, 显示为NULL</p></li><li><p>type 列: 访问类型, 表示找到所查询数据的方法。性能由好到差:</p></li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>system/const</td><td>表中有且只有一个匹配的行时使用, 如对主键(primary key)或是唯一索引(unique index)的查询, 这是效率最高的连接方式。system是const的一种特殊情况,既表本身只有一行数据的情况。</td></tr><tr><td>eq_ref</td><td>根据唯一索引或者主键查找, 对于每个索引键, 表中只有一条记录与之匹配。</td></tr><tr><td>ref</td><td>非唯一索引查找, 返回匹配某个单独值的所有行。</td></tr><tr><td>ref_or_null</td><td>类似于ref类型的查询,但是附加了对NULL值列的查询</td></tr><tr><td>index_merge</td><td>该连接查询表示使用了索引合并优化方法。</td></tr><tr><td>range</td><td>索引范围扫描, 常见于between、&gt;、&lt; 这样的查询条件</td></tr><tr><td>index</td><td>full index scan 全索引扫描, 同ALL的区别是, 遍历的是索引树</td></tr><tr><td>all</td><td>full table scan 全表扫描, 这是效率最差的连接方式</td></tr></tbody></table><p>system<br><img src="./images/mysql-type-system.png" alt="avatar"></p><p>const<br><img src="./images/mysql-type-const.png" alt="avatar"></p><p>eq_ref<br><img src="./images/mysql-type-eq_ref.png" alt="avatar"></p><p>ref<br><img src="./images/mysql-type-ref.png" alt="avatar"></p><p>ref_or_null<br><img src="./images/mysql-type-ref-or-null.png" alt="avatar"></p><p>index_merge<br><img src="./images/mysql-type-indexMerge.png" alt="avatar"></p><p>range<br><img src="./images/mysql-type-range.png" alt="avatar"></p><p>index<br><img src="./images/mysql-type-index.png" alt="avatar"></p><p>all<br><img src="./images/mysql-type-all.png" alt="avatar"></p><ul><li>possible_keys: 表示此次查询中可能使用的索引。</li><li>key: 表示实际在此次查询中使用的索引。</li><li>key_len: 表示实际使用的索引的最大长度。复合索引可能为部分列(根据查询条件)长度之和。该值越小越好。</li></ul><blockquote><p>如何计算key_len</p></blockquote><pre><code>1. 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 2. 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 3. varchar 这种动态字符串要加 2 个字节4. 允许为空的字段要加 1 个字节</code></pre><ul><li>ref: 表示哪些列或常量被用于索引查找, 即连接查询的条件。</li><li>rows: 根据统计信息预估的扫描的行数</li><li>filtered: 表示返回结果的行数占需读取行数的百分比, 该值越高, 说明性能越好。</li><li>extra: 表示查询的其他信息:</li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>Distinct</td><td>优化distinct操作,在找到第一匹配的元组后即停止找同样值的动作</td></tr><tr><td>Not exists</td><td>使用not exists来优化查询</td></tr><tr><td>Using filesort</td><td>说明MySQL会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取。MySQL无法利用索引完成的排序操作称为”文件排序”</td></tr><tr><td>Using temporary</td><td>MySQL需要使用临时表来处理查询, 常见于order by,sub_query和group by</td></tr><tr><td>Using index</td><td>使用覆盖索引(Covering index)来进行查询，避免访问表的数据行。如果同时出现Using where，表明索引被用来执行索引键值的查找;如果没有Using where，表明索引用来读取数据而非执行查找动作。</td></tr><tr><td>Using where</td><td>使用where条件来过滤数据</td></tr><tr><td>Using join buffer</td><td>使用了连接缓存</td></tr><tr><td>impossible where</td><td>where子句的值总是false，不能用来获取任何元组</td></tr><tr><td>select tables optimized away</td><td>直接通过索引来获得数据, 不用访问表(MyISAM引擎优化)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;explain&lt;/code&gt;可以查看SQL语句的执行计划。下面, 我们就对&lt;code&gt;explain&lt;/code&gt;查询出来的字段做一些使用说明。&lt;br&gt;返回的信息有10列, 分别是:&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 小技巧</title>
    <link href="http://yoursite.com/2020/11/29/mysql-tips/"/>
    <id>http://yoursite.com/2020/11/29/mysql-tips/</id>
    <published>2020-11-29T15:27:45.000Z</published>
    <updated>2020-11-30T01:00:11.902Z</updated>
    
    <content type="html"><![CDATA[<p>接下来一段时间, 会将主要精力投入在SQL优化 以及工作中常用的一些SQL小技巧总结。当然啦, 也会对Hive、Spark SQL 和 Presto 中的SQL使用做一些总结。之前SQL写得比较少, 更多的是用的pyspark进行大数据处理, 后端服务更多的用Mybatis自动生成工具来生成DAO层SQL代码,然后在Service层进行多次调用, 一是因为业务逻辑不复杂, 二是因为性能要求也没那么高。不过, 总感觉SQL这块如果不掌握的话, 可能后面发展会受限。好了, 废话不多说, 我们开始一段时间的 SQL 之旅吧。</p><a id="more"></a><h4 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h4><p>表1. user:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/user.png"></p><p>表2. job:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/job.png"></p><p>表3. sports_duration:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/sports_duration.png"></p><h4 id="1-如何在MySQL中使用full-join"><a href="#1-如何在MySQL中使用full-join" class="headerlink" title="1. 如何在MySQL中使用full join?"></a>1. 如何在MySQL中使用full join?</h4><p>场景: 将上面的user 表和 job表 合成一张大表。</p><p>full join 就是取两者的并集, 而MySQL中是不能使用full join 的, 下面来说下解决方法:<br>使用表user left join 表job, 然后 union all 表user right join 表job(其实也就是表job left join 表user)即可, union all 就是两者的并集。</p><p>sql 如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, j.name <span class="keyword">as</span> jname, j.job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">JOIN</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.name</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, j.name <span class="keyword">as</span> jname, j.job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">right</span> <span class="keyword">JOIN</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.name;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/full_join.png"></p><p>通过上图, 我们也可以很清楚的看到 left join 和 right join 后的效果。<br>user left join job 就是user 表作为主表, 将 job 表中与 user表有关联关系的数据作为补充, 详见 上图 left join 红框。<br>另外, 通过指定 where jname is null, 我们也可以取到 user 表中有而 job 表中不存在的用户。<br>right join 同理, 这里就不赘述了。</p><h4 id="2-如何更新使用过滤条件中包括自身的表？"><a href="#2-如何更新使用过滤条件中包括自身的表？" class="headerlink" title="2. 如何更新使用过滤条件中包括自身的表？"></a>2. 如何更新使用过滤条件中包括自身的表？</h4><p>场景: 把同时存在于 user表 和 job表的记录的用户在user 表中的age 字段更新为30。<br>错误示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age=<span class="number">30</span> <span class="keyword">where</span> user.name <span class="keyword">in</span> (<span class="keyword">select</span> j.name <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> job j <span class="keyword">on</span> u.name=j.name);</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update user set age&#x3D;30 where user.name in (select j.name from user u join job j on u.name&#x3D;j.name)</span><br><span class="line">&gt; 1093 - You can&#39;t specify target table &#39;user&#39; for update in FROM clause</span><br></pre></td></tr></table></figure><p>说明： MySQL 中不支持这样操作, 在 SQLServer 或者 Oracle中可以正常执行。 </p><p>正确解法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> u <span class="keyword">join</span> (<span class="keyword">select</span> j.name <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> job j <span class="keyword">on</span> u.name=j.name) j <span class="keyword">on</span> a.name=j.name <span class="keyword">set</span> u.age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>更新结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/user_join_update.png"></p><h4 id="3-如何使用-join-来优化子查询"><a href="#3-如何使用-join-来优化子查询" class="headerlink" title="3. 如何使用 join 来优化子查询?"></a>3. 如何使用 join 来优化子查询?</h4><p>先看下面这个带有子查询的sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, (<span class="keyword">select</span> job <span class="keyword">from</span> job <span class="keyword">where</span> job.name = u.name ) <span class="keyword">as</span> job <span class="keyword">from</span> <span class="keyword">user</span> u;</span><br></pre></td></tr></table></figure><p>使用 join 优化:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, u.age, u.hobby, job <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">join</span> job j <span class="keyword">on</span> u.<span class="string">`name`</span> = j.<span class="string">`name`</span>;</span><br></pre></td></tr></table></figure><h4 id="4-使用join来优化聚合子查询"><a href="#4-使用join来优化聚合子查询" class="headerlink" title="4. 使用join来优化聚合子查询"></a>4. 使用join来优化聚合子查询</h4><p>场景: 找出user 表中三人, 各自运动时长最长的日期。新增表 sports_duration, duration 为运动时长, 单位: 分钟</p><p>聚合子查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, s.day, s.duration <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">join</span> sports_duration s <span class="keyword">on</span> u.name=s.name </span><br><span class="line"><span class="keyword">where</span> s.duration=(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(c.duration) <span class="keyword">from</span> sports_duration c <span class="keyword">where</span> c.name=s.name</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/max_duration.png"></p><p>使用join优化后, 避免子查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, s.day, s.duration <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">join</span> sports_duration s <span class="keyword">on</span> u.name=s.name</span><br><span class="line"><span class="keyword">join</span> sports_duration c <span class="keyword">on</span> c.name=s.name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> u.name,s.day,s.duration</span><br><span class="line"><span class="keyword">having</span> s.duration=<span class="keyword">max</span>(c.duration);</span><br></pre></td></tr></table></figure><p>返回的结果集是相同的。</p><h4 id="5-如何实现分组选择"><a href="#5-如何实现分组选择" class="headerlink" title="5. 如何实现分组选择?"></a>5. 如何实现分组选择?</h4><p>在 Oracle、SQLServer、PgSQL中可以使用分区查询函数实现:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> u.name, s.day, s.duration, row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> u.name <span class="keyword">order</span> <span class="keyword">by</span> s.duration) cnt</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">join</span> sports_duration s </span><br><span class="line">    <span class="keyword">on</span> u.name = s.name</span><br><span class="line">) <span class="keyword">select</span> * <span class="keyword">from</span> tmp <span class="keyword">where</span> cnt &lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>但是, 在 MySQL中不支持。</p><p>我们可以这样做:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, d.day, d.duration <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span>, (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> sports_duration s <span class="keyword">where</span> s.name=c.name <span class="keyword">and</span> c.duration &lt;= s.duration) <span class="keyword">as</span> cnt <span class="keyword">from</span> sports_duration c</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span></span><br><span class="line">) d <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> d.name = u.name</span><br><span class="line"><span class="keyword">where</span> cnt &lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/duration_top_2.png"></p><p>下面我们来拆分这个SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, d.day, d.duration, cnt <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span>, (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> sports_duration s <span class="keyword">where</span> s.name=c.name <span class="keyword">and</span> c.duration &lt;= s.duration) <span class="keyword">as</span> cnt <span class="keyword">from</span> sports_duration c</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>, <span class="keyword">day</span>, <span class="keyword">duration</span></span><br><span class="line">) d <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> d.name = u.name;</span><br></pre></td></tr></table></figure><p>去掉 where条件, 加上返回 cnt 字段, 就可以很清晰的看到明白这个sql的逻辑了, 结果如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/mysql/duration_top_cnt.png"><br>利用子查询中统计出用户运动耗时大于等于当前运动记录的条数, 然后再进行过滤。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;接下来一段时间, 会将主要精力投入在SQL优化 以及工作中常用的一些SQL小技巧总结。当然啦, 也会对Hive、Spark SQL 和 Presto 中的SQL使用做一些总结。之前SQL写得比较少, 更多的是用的pyspark进行大数据处理, 后端服务更多的用Mybatis自动生成工具来生成DAO层SQL代码,然后在Service层进行多次调用, 一是因为业务逻辑不复杂, 二是因为性能要求也没那么高。不过, 总感觉SQL这块如果不掌握的话, 可能后面发展会受限。好了, 废话不多说, 我们开始一段时间的 SQL 之旅吧。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://yoursite.com/2020/10/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/10/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-03T14:31:45.000Z</published>
    <updated>2020-10-08T15:56:29.334Z</updated>
    
    <content type="html"><![CDATA[<style>table th:nth-of-type(1){    width: 17%;}table th:nth-of-type(2){    width: 83%;}</style><h5 id="正则示例"><a href="#正则示例" class="headerlink" title="正则示例"></a>正则示例</h5><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>this is text</td><td>匹配字符串 “this is text”</td></tr><tr><td>this\s+is\s+text</td><td>注意字符串中的 \s+。匹配单词 “this” 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td></tr><tr><td>^\d+(.\d+)?</td><td>^ 定义了以什么开始; \d+ 匹配一个或多个数字; ? 设置括号内的选项是可选的; . 匹配 “.”; 可以匹配的实例：”5”, “1.5” 和 “2.21”。</td></tr></tbody></table><a id="more"></a><h5 id="java中的正则"><a href="#java中的正则" class="headerlink" title="java中的正则"></a>java中的正则</h5><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：<br>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p><ul><li>matches()  尝试将整个字符串序列与该模式匹配</li><li>find()  该方法扫码输入的序列, 查找与该模式匹配的<code>下一个</code>子序列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pattern PATTERN &#x3D; Pattern.compile(&quot;\\d+ \\w+&quot;);</span><br><span class="line">Matcher matcher &#x3D; PATTERN.matcher(&quot;1 apple&quot;);</span><br><span class="line">boolean find &#x3D; matcher.find();</span><br><span class="line">System.out.println(&quot;find:&quot; + find);</span><br><span class="line">boolean find1 &#x3D; matcher.find();</span><br><span class="line">System.out.println(&quot;find1:&quot; + find1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; output</span><br><span class="line">find:true</span><br><span class="line">find1:false</span><br></pre></td></tr></table></figure></li><li>group() 捕获组取值, 一般与find() 一起用</li><li>group(num) 捕获组取值, 一般与matches() 一起用</li></ul></li><li><p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><p>一般是两种用途: </p><ol><li>判断字符串中是否包含某个子串; </li><li>提取某个字符串中符合正则规则的内容</li></ol><blockquote><p>注: 正则中的 <code>\</code> 在Java中需要使用 <code>\\</code></p></blockquote><h5 id="正则表达式-匹配字符-集合"><a href="#正则表达式-匹配字符-集合" class="headerlink" title="正则表达式-匹配字符(集合)"></a>正则表达式-匹配字符(集合)</h5><ul><li><p>匹配普通字符:<br>字母、数字、汉字、下划线, 以及没有特殊定义的标点符号</p></li><li><p>匹配转义字符</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\n</td><td>代表换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\、^、$、(、)、{、}、?、+、*、\、|、[、]</td><td>代表字符本身(就是在正则表达式中有特殊作用的字符需要做转义处理)</td></tr></tbody></table></li><li><p>标准字符集合</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]</td></tr><tr><td>\w</td><td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效</td></tr><tr><td>\W</td><td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效</td></tr><tr><td>\S</td><td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效</td></tr><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式</td></tr></tbody></table></li><li><p>自定义字符集合<br>[] 方括号匹配方式, 能够匹配方括号中的任意一个字符。</p><table><thead><tr><th>字符集合</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 a 或 b 或 5 或 @</td></tr><tr><td>[^abc]</td><td>匹配 a、 b、 c之外的任意一个字符</td></tr><tr><td>[a-z]</td><td>匹配 a~z 之间的任意一个字符</td></tr><tr><td>[^A-F0-3]</td><td>匹配 A<del>F, 0</del>3 之外的任意一个字符</td></tr></tbody></table></li></ul><p>注意: </p><ol><li>正则表达式的特殊符号, 被包含到中括号中, 则失去特殊意义, 除了 ^ 和 - 之外</li><li>标准字符集合, 除小数点外, 如果被包含于中括号中, 自定义字符集合将包含该集合, 比如: [\d.-+] 将匹配: 数字 或 小数点 或 + 或 -</li></ol><h5 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h5><ul><li>修饰匹配次数的特殊符号。</li></ul><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>{n}</td><td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td>{n,}</td><td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td>{n,m}</td><td>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>匹配表达式0次或1次, 相当于 {0,1}</td></tr><tr><td>+</td><td>表达式至少出现一次, 相当于 {1,}</td></tr><tr><td>*</td><td>表达式不出现或者出现任意次, 相当于{0,}</td></tr></tbody></table><p>注:</p><ul><li>{0,1} 中逗号左边必须有, 不能有 {,6} 这种形式</li><li>匹配规则默认为贪婪模式, 即匹配字符越多越好</li><li>匹配次数中的非贪婪模式(匹配字符越少越好, 修饰匹配次数的特殊符合后再加一个 ?)</li></ul><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><ul><li>匹配符合某种条件的位置<table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>字符串开始的地方进行匹配([]外)</td></tr><tr><td>$</td><td>字符串结束的地方进行匹配</td></tr><tr><td>\b</td><td>匹配一个单次边界，即前面或后面的字符至少有一个是[A-Za-z0-9_]以外的字符</td></tr><tr><td>^A</td><td>多行模式下, 匹配第一个出现的字符</td></tr><tr><td>^Z</td><td>多行模式下, 匹配最后一个出现的字符</td></tr></tbody></table></li></ul><h5 id="选择符和分组"><a href="#选择符和分组" class="headerlink" title="选择符和分组"></a>选择符和分组</h5><table><thead><tr><th align="left">字符</th><th>作用</th></tr></thead><tbody><tr><td align="left"><code>|</code></td><td>或</td></tr><tr><td align="left">()</td><td>匹配 pattern 并捕获该匹配的子表达式。可以使用 <code>$0</code>…<code>$9</code> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“</td></tr></tbody></table><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><ul><li>每一对 ()会分配一个编号, 使用 () 的捕获根据<code>左括号的顺序</code>从1开始自动编号</li><li>通过反向引用, 可以对已捕获的字符串进行引用</li></ul>]]></content>
    
    
    <summary type="html">&lt;style&gt;
table th:nth-of-type(1){
    width: 17%;
}
table th:nth-of-type(2){
    width: 83%;
}
&lt;/style&gt;


&lt;h5 id=&quot;正则示例&quot;&gt;&lt;a href=&quot;#正则示例&quot; class=&quot;headerlink&quot; title=&quot;正则示例&quot;&gt;&lt;/a&gt;正则示例&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;正则表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;this is text&lt;/td&gt;
&lt;td&gt;匹配字符串 “this is text”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;this\s+is\s+text&lt;/td&gt;
&lt;td&gt;注意字符串中的 \s+。匹配单词 “this” 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^\d+(.\d+)?&lt;/td&gt;
&lt;td&gt;^ 定义了以什么开始; \d+ 匹配一个或多个数字; ? 设置括号内的选项是可选的; . 匹配 “.”; 可以匹配的实例：”5”, “1.5” 和 “2.21”。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="正则表达式" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
    <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Azkaban-1.搭建Azkaban源代码阅读环境</title>
    <link href="http://yoursite.com/2020/05/23/Azkaban-1.%E6%90%AD%E5%BB%BAAzkaban%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/05/23/Azkaban-1.%E6%90%AD%E5%BB%BAAzkaban%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/</id>
    <published>2020-05-23T08:26:45.000Z</published>
    <updated>2020-10-08T15:52:27.640Z</updated>
    
    <content type="html"><![CDATA[<p>在公司的日常工作中， 经常会用到 Azkaban。作为一种工作流管理系统, 对我来说, 的确有学习的价值。</p><p>本文将会使用最新版的Azkaban源代码, 编译并搭建一套可运行调试的系统。开发工具使用的是IDEA, 运行环境是CentOS7。</p><h4 id="从github下载源代码"><a href="#从github下载源代码" class="headerlink" title="从github下载源代码"></a>从github下载源代码</h4><p>截止目前，最新的tag版本是: 3.86.0<br>可以直接点击下载源码: <a href="https://github.com/azkaban/azkaban/archive/3.86.0.zip " target="_blank" rel="noopener">3.86.0</a></p><a id="more"></a><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>用IDEA打开, File -&gt; Open… -&gt; 选择已解压的代码目录 -&gt; 点击 OK。<br>此时, IDEA会自动同步一些Gradle项目的配置，稍微等待一会。</p><p>为了解决gradle项目下载依赖慢的问题， 我们可以加上阿里云的maven仓库地址。<br>在azkaban根目录下的 build.gradle 中加入下面内容即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url <span class="string">"http://maven.aliyun.com/nexus/content/groups/public"</span> &#125;</span><br></pre></td></tr></table></figure><p>加入后的效果是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  apply plugin: &#39;jacoco&#39;</span><br><span class="line"></span><br><span class="line">  repositories &#123;</span><br><span class="line">    maven &#123; url &quot;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&quot; &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    mavenLocal()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 这里需要保留原来的仓库地址, 因为有些依赖阿里云仓库下载不到</p></blockquote><p>再配置一个 npm的淘宝源, 毕竟国外的不太稳定。<br>在用户目录下, 创建 .npmrc 文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~&#x2F;.npmrc</span><br></pre></td></tr></table></figure><p>再加入以下内容即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure><p>配置好之后, 我们就可以执行以下命令编译了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build -x <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>编译成功后, 就有了az-web 和 az-exec 的可运行程序压缩包了。</p><h4 id="数据库、表初始化"><a href="#数据库、表初始化" class="headerlink" title="数据库、表初始化"></a>数据库、表初始化</h4><p>推荐使用 MySQL5.7.x </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line">mysql&gt; CREATE DATABASE azkaban;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建用户, username/password 自定义</span></span><br><span class="line">mysql&gt; CREATE USER 'username'@'%' IDENTIFIED BY 'password';</span><br><span class="line"></span><br><span class="line"><span class="comment">--授权, &lt;username&gt; 改为你自己的用户名 </span></span><br><span class="line">mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE ON azkaban.* to '&lt;username&gt;'@'%' WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>调整Mysql Packet Size, 找到MySQL的配置文件,修改<code>max_allowed_packet=1024M</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">max_allowed_packet&#x3D;1024M</span><br></pre></td></tr></table></figure><p>重启MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;service mysqld restart</span><br></pre></td></tr></table></figure><p>使用初始化sql建表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置</span></span><br><span class="line">azkaban-3.86.0\azkaban-db\build\sql\create-all-sql-0.1.0-SNAPSHOT.sql</span><br></pre></td></tr></table></figure><h4 id="运行azkaban-Exec节点"><a href="#运行azkaban-Exec节点" class="headerlink" title="运行azkaban Exec节点"></a>运行azkaban Exec节点</h4><p>编译后的压缩包路径: azkaban-exec-server/build/distributions/azkaban-exec-server-0.1.0-SNAPSHOT.zip</p><p>1.更改配置文件<br>上传 azkaban-exec-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-exec-server/conf/azkaban.properties 配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库信息</span></span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=192.168.3.25</span><br><span class="line">mysql.database=azkaban</span><br><span class="line">mysql.user=root</span><br><span class="line">mysql.password=123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行节点信息</span></span><br><span class="line">executor.port=12321</span><br><span class="line">azkaban.use.multiple.executors=<span class="literal">true</span></span><br><span class="line">azkaban.executorselector.filters=StaticRemainingFlowSize,MinimumFreeMemory,CpuStatus</span><br><span class="line">azkaban.executorselector.comparator.NumberOfAssignedFlowComparator=1</span><br><span class="line">azkaban.executorselector.comparator.Memory=1</span><br><span class="line">azkaban.executorselector.comparator.LastDispatched=1</span><br><span class="line">azkaban.executorselector.comparator.CpuUsage=1</span><br></pre></td></tr></table></figure><p>2.设置远程debug<br>2.1 编辑文件 azkaban-exec-server/bin/internal/internal-start-executor.sh， <strong>增加</strong>一个 AZKABAN_OPTS 值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">AZKABAN_OPTS=<span class="string">"<span class="variable">$AZKABAN_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5554"</span></span><br><span class="line">java <span class="variable">$AZKABAN_OPTS</span> <span class="variable">$JAVA_LIB_PATH</span> -cp <span class="variable">$CLASSPATH</span> azkaban.execapp.AzkabanExecutorServer -conf <span class="variable">$conf</span> <span class="variable">$@</span> &amp;</span><br></pre></td></tr></table></figure><p>2.2 IDEA中配置<br>点击编辑运行时配置 -&gt; 点击左上角的 <code>+</code> ，选择 Remote 选项。配置如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.3.png"><br>说明:</p><ul><li>Host: 为az执行节点的IP</li><li>Port: 为 上面我们配置的那个远程debug端口</li><li>Use module classpath: 为az-exec模块的main</li></ul><p>点击OK即可, 需要远程服务先启动,才能进行远程debug操作。</p><p>3.运行并激活az-exec<br>运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> azkaban-exec-server</span><br><span class="line">bin/start-exec.sh</span><br></pre></td></tr></table></figure><p>激活:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G &quot;http:&#x2F;&#x2F;192.168.3.25:12321&#x2F;executor?action&#x3D;activate&quot; &amp;&amp; echo</span><br></pre></td></tr></table></figure><ul><li>192.168.3.25:12321 为 az执行节点的地址</li></ul><p>此时, 可以发现azkaban库 executors 表中已经有执行节点的记录<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.4.png"></p><h4 id="运行azkaban-Web节点"><a href="#运行azkaban-Web节点" class="headerlink" title="运行azkaban Web节点"></a>运行azkaban Web节点</h4><p>编译后的压缩包路径:<br>azkaban-web-server/build/distributions/azkaban-web-server-0.1.0-SNAPSHOT.zip</p><p>1.更改配置文件<br>上传 azkaban-web-server-0.1.0-SNAPSHOT.zip 到 centos 服务器上，解压。修改 azkaban-web-server/conf/azkaban.properties 配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库信息</span></span><br><span class="line">mysql.port=3306</span><br><span class="line">mysql.host=192.168.3.25</span><br><span class="line">mysql.database=azkaban</span><br><span class="line">mysql.user=root</span><br><span class="line">mysql.password=123456</span><br></pre></td></tr></table></figure><p>2.设置远程debug<br>2.1 编辑文件 azkaban-web-server/bin/internal/internal-start-web.sh， <strong>增加</strong>一个 AZKABAN_OPTS 值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">AZKABAN_OPTS=<span class="string">"<span class="variable">$AZKABAN_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555"</span></span><br><span class="line">java <span class="variable">$AZKABAN_OPTS</span> <span class="variable">$JAVA_LIB_PATH</span> -cp <span class="variable">$CLASSPATH</span> azkaban.webapp.AzkabanWebServer -conf <span class="variable">$conf</span> <span class="variable">$@</span> &amp;</span><br></pre></td></tr></table></figure><p>2.2 IDEA中配置<br>点击编辑运行时配置 -&gt; 点击左上角的 <code>+</code> ，选择 Remote 选项。配置如下图:<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.5.png"></p><p>3.运行az-web</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> azkaban-web-server</span><br><span class="line">bin/start-web.sh</span><br></pre></td></tr></table></figure><p>4.登录<br>Azkaban默认使用的xml来管理用户。配置文件目录: azkaban-web-server/conf/azkaban-users.xml<br>访问 <a href="http://192.168.3.25:8081" target="_blank" rel="noopener">http://192.168.3.25:8081</a>, 使用azkaban/azkaban 即可登录。</p><ul><li>192.168.3.25: 为 az-web的ip</li><li>8081: 为az-web的端口</li></ul><h4 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h4><p>在 az-web 和 az-exec 都启动之后, 先确保所有端口都能正常访问, 我这儿配置的是 </p><ul><li>az-exec服务端口: 12321</li><li>az-exec远程debug端口: 5554</li><li>az-web服务端口: 8091</li><li>az-web远程debug端口: 5555</li></ul><p>然后在IDEA中运行下图中的这两项即可。<br><img src="https://matthewblog.oss-cn-hangzhou.aliyuncs.com/blog/new/az1.6.png" ><br>在想要看细节的地方打上断点, 就可以愉快玩耍啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在公司的日常工作中， 经常会用到 Azkaban。作为一种工作流管理系统, 对我来说, 的确有学习的价值。&lt;/p&gt;
&lt;p&gt;本文将会使用最新版的Azkaban源代码, 编译并搭建一套可运行调试的系统。开发工具使用的是IDEA, 运行环境是CentOS7。&lt;/p&gt;
&lt;h4 id=&quot;从github下载源代码&quot;&gt;&lt;a href=&quot;#从github下载源代码&quot; class=&quot;headerlink&quot; title=&quot;从github下载源代码&quot;&gt;&lt;/a&gt;从github下载源代码&lt;/h4&gt;&lt;p&gt;截止目前，最新的tag版本是: 3.86.0&lt;br&gt;可以直接点击下载源码: &lt;a href=&quot;https://github.com/azkaban/azkaban/archive/3.86.0.zip &quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.86.0&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="IDEA" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/IDEA/"/>
    
    
    <category term="Azkaban" scheme="http://yoursite.com/tags/Azkaban/"/>
    
    <category term="调试" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
    <category term="源码阅读" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
